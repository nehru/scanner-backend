# =============================================================================
# JAVA SECURITY RULES - VERIFIED AND CORRECTED
# =============================================================================

rules:
  # ===========================================================================
  # 1. SQL INJECTION
  # ===========================================================================
  
  - id: java-sql-injection-statement
    message: 'SQL injection vulnerability: String concatenation in Statement execution'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          Statement $STMT = ...;
          ...
      - pattern-either:
          - pattern: $STMT.executeQuery("..." + $VAR + "...")
          - pattern: $STMT.execute("..." + $VAR + "...")
          - pattern: $STMT.executeUpdate("..." + $VAR + "...")
      - pattern-not-inside: |
          Paths.get(...)
      - pattern-not-inside: |
          Files.readString(...)
      - pattern-not-inside: |
          Files.write(...)
    metadata:
      category: sql-injection
      cwe: CWE-89
      solution: |
        Replace Statement with PreparedStatement to prevent SQL injection:
        
        // Instead of:
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE id = " + userId);
        
        // Use:
        PreparedStatement pstmt = connection.prepareStatement("SELECT * FROM users WHERE id = ?");
        pstmt.setString(1, userId);
        ResultSet rs = pstmt.executeQuery();

  - id: java-hardcoded-credentials
    message: 'Hardcoded credentials: Sensitive credentials in source code'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Direct hardcoded passwords
          - patterns:
              - pattern: $VAR = $VALUE
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|passwd|pwd|secret|apikey|api_key|token|credential).*
              - metavariable-regex:
                  metavariable: $VALUE
                  regex: "[A-Za-z0-9!@#$%^&*()_+={}\\\\[\\\\]:\"';'<>?,.\/]{8,}"
          # Database connection strings with credentials
          - patterns:
              - pattern: $VAR = $CONN_STRING
              - metavariable-regex:
                  metavariable: $CONN_STRING
                  regex: ".*password=.+"
          # API keys and tokens
          - patterns:
              - pattern: $VAR = $VALUE
              - metavariable-regex:
                  metavariable: $VALUE
                  regex: "(sk-[a-zA-Z0-9]{32,}|[a-f0-9]{32,}|[A-Za-z0-9+/]{40,}={0,2})"
    metadata:
      category: security
      cwe: CWE-798
      solution: |
        Remove hardcoded credentials and use secure configuration management:
        
        // Instead of:
        private static final String ADMIN_PASSWORD = "password123";
        private static final String DB_CONNECTION = "jdbc:mysql://localhost:3306/app?user=root&password=admin123";
        private static final String API_KEY = "sk-1234567890abcdef1234567890abcdef";
        
        // Use environment variables:
        private static final String ADMIN_PASSWORD = System.getenv("ADMIN_PASSWORD");
        private static final String DB_CONNECTION = System.getenv("DATABASE_URL");
        private static final String API_KEY = System.getenv("API_KEY");
        
        // Or use configuration files (excluded from version control):
        Properties config = new Properties();
        config.load(new FileInputStream("config.properties"));
        String adminPassword = config.getProperty("admin.password");
        
        // For Spring applications, use @Value annotation:
        @Value("${admin.password}")
        private String adminPassword;

  - id: java-command-injection
    message: 'Command injection: User input in system command execution'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: Runtime.getRuntime().exec($CMD + ...)
          - pattern: Runtime.getRuntime().exec("..." + $VAR + "...")
          - pattern: ProcessBuilder($CMD + ...).start()
          - pattern: new ProcessBuilder("..." + $VAR + "...")
    metadata:
      category: command-injection
      cwe: CWE-78
      solution: |
        Avoid concatenating user input directly into system commands. Use ProcessBuilder with separate arguments:
        
        // Instead of:
        String userCmd = request.getParameter("cmd");
        Runtime.getRuntime().exec("ping -c 1 " + userCmd);
        
        // Use ProcessBuilder with separate arguments:
        String userCmd = request.getParameter("cmd");
        ProcessBuilder pb = new ProcessBuilder("ping", "-c", "1", userCmd);
        Process process = pb.start();
        
        // Or validate input against whitelist:
        if (!userCmd.matches("^[a-zA-Z0-9.-]+$")) {
            throw new IllegalArgumentException("Invalid command input");
        }

  - id: java-taint-http-to-sql
    message: 'Taint flow: HTTP parameter reaches SQL execution'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          String $VAR = request.getParameter(...);
          ...
      - pattern: $STMT.executeQuery("..." + $VAR + "...")
    metadata:
      category: sql-injection
      cwe: CWE-89
      taint_flow: true
      solution: |
        Use PreparedStatement with parameterized queries instead of concatenation:
        
        // Instead of:
        String userId = request.getParameter("id");
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE id = '" + userId + "'");
        
        // Use:
        String userId = request.getParameter("id");
        PreparedStatement pstmt = connection.prepareStatement("SELECT * FROM users WHERE id = ?");
        pstmt.setString(1, userId);
        ResultSet rs = pstmt.executeQuery();

  - id: java-jpa-query-annotation-injection
    message: 'SQL injection vulnerability: User input in JPA @Query annotation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: '@Query("SELECT u FROM User u WHERE u.name = ''" + $PARAM + "''")'
          - pattern: '@Query(value = "SELECT * FROM users WHERE id = " + $PARAM, nativeQuery = true)'
    metadata:
      category: sql-injection
      cwe: CWE-89
      framework: jpa
      solution: |
        Use parameterized JPA queries instead of string concatenation:
        
        // Instead of:
        @Query("SELECT u FROM User u WHERE u.name = '" + userName + "'")
        List<User> findByName();
        
        // Use:
        @Query("SELECT u FROM User u WHERE u.name = :name")
        List<User> findByName(@Param("name") String name);
        
        // Or for native queries:
        @Query(value = "SELECT * FROM users WHERE id = ?1", nativeQuery = true)
        User findById(Long id);

  - id: java-mybatis-sql-injection
    message: 'SQL injection vulnerability: MyBatis with string concatenation'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_INPUT = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: $SESSION.selectList($STATEMENT + $USER_INPUT + ...)
              - pattern: $SESSION.selectList($STATEMENT + $USER_INPUT)
              - pattern: $SESSION.selectList($USER_INPUT + ...)
              - pattern: $MAPPER.query($QUERY + $USER_INPUT + ...)
              - pattern: $MAPPER.query($QUERY + $USER_INPUT)
    metadata:
      category: sql-injection
      cwe: CWE-89
      framework: mybatis
      solution: |
        Use MyBatis parameterized queries instead of string concatenation:
        
        // Instead of:
        String userId = request.getParameter("id");
        List<User> users = session.selectList("SELECT * FROM users WHERE id = " + userId);
        
        // Use:
        String userId = request.getParameter("id");
        Map<String, Object> params = new HashMap<>();
        params.put("userId", userId);
        List<User> users = session.selectList("getUserById", params);
        
        // In mapper XML: SELECT * FROM users WHERE id = #{userId}

  - id: java-cassandra-injection
    message: 'CQL injection vulnerability: Cassandra query with string concatenation'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_INPUT = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: $SESSION.execute($CQL + $USER_INPUT + ...)
              - pattern: $SESSION.execute($CQL + $USER_INPUT)
              - pattern: $SESSION.execute($USER_INPUT + ...)
              - pattern: SimpleStatement.newInstance($QUERY + $USER_INPUT + ...)
              - pattern: SimpleStatement.newInstance($QUERY + $USER_INPUT)
    metadata:
      category: sql-injection
      cwe: CWE-89
      library: cassandra
      solution: |
        Use prepared statements for Cassandra CQL queries:
        
        // Instead of:
        String userId = request.getParameter("id");
        session.execute("SELECT * FROM users WHERE id = " + userId);
        
        // Use:
        String userId = request.getParameter("id");
        PreparedStatement prepared = session.prepare("SELECT * FROM users WHERE id = ?");
        session.execute(prepared.bind(userId));

  - id: java-mongodb-injection
    message: 'NoSQL injection vulnerability: MongoDB query with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $COLLECTION.find(Document.parse($USER_JSON))
          - pattern: $COLLECTION.aggregate(Arrays.asList(Document.parse($USER_INPUT)))
    metadata:
      category: sql-injection
      cwe: CWE-943
      library: mongodb
      solution: |
        Build MongoDB queries programmatically instead of parsing user JSON:
        
        // Instead of:
        String userQuery = request.getParameter("query");
        collection.find(Document.parse(userQuery));
        
        // Use:
        String userId = request.getParameter("userId");
        Document query = new Document("userId", userId);
        collection.find(query);

  - id: java-spring-jdbctemplate-injection-v2
    message: 'SQL injection vulnerability: String concatenation in JdbcTemplate'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Direct concatenation in method calls
          - pattern: $JDBC.queryForObject($SQL + ..., ...)
          - pattern: $JDBC.query($SQL + ..., ...)
          - pattern: $JDBC.update($SQL + ..., ...)
          
          # Variable concatenation pattern (the missing piece!)
          - pattern: |
              $SQL = $STR + $VAR;
              ...
              $JDBC.query($SQL, ...);
              
          - pattern: |
              $SQL = $STR + $VAR;
              ...
              $JDBC.queryForObject($SQL, ...);
              
          - pattern: |
              $SQL = $STR + $VAR;
              ...
              $JDBC.update($SQL, ...);  
    metadata:
      category: sql-injection
      cwe: CWE-89
      framework: spring
      solution: |
        Use JdbcTemplate with parameterized queries:
        
        // Instead of:
        String userId = request.getParameter("id");
        String sql = "SELECT * FROM users WHERE id = " + userId;
        List<User> users = jdbcTemplate.query(sql, new UserRowMapper());
        
        // Use:
        String userId = request.getParameter("id");
        String sql = "SELECT * FROM users WHERE id = ?";
        List<User> users = jdbcTemplate.query(sql, new UserRowMapper(), userId);
        
        // Or use named parameters:
        String sql = "SELECT * FROM users WHERE id = :userId";
        Map<String, Object> params = Map.of("userId", userId);
        List<User> users = namedParameterJdbcTemplate.query(sql, params, new UserRowMapper());

  # ===========================================================================
  # 2. COMMAND INJECTION
  # ===========================================================================

  - id: java-taint-http-to-command
    message: 'Taint flow: HTTP parameter reaches command execution'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          String $VAR = request.getParameter(...);
          ...
      - pattern: Runtime.getRuntime().exec($VAR)
    metadata:
      category: command-injection
      cwe: CWE-78
      taint_flow: true
      solution: |
        Validate and sanitize user input before command execution, or avoid direct execution:
        
        // Instead of:
        String userCommand = request.getParameter("command");
        Runtime.getRuntime().exec(userCommand);
        
        // Use:
        String userAction = request.getParameter("action");
        if (Arrays.asList("start", "stop", "restart").contains(userAction)) {
            ProcessBuilder pb = new ProcessBuilder("systemctl", userAction, "myservice");
            Process p = pb.start();
        } else {
            throw new IllegalArgumentException("Invalid action");
        }

  # ===========================================================================
  # 3. PATH TRAVERSAL
  # ===========================================================================

  - id: java-path-traversal-file-operation
    message: 'Path traversal: Unsanitized file path concatenation'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern: $VAR = $BASE + $FILENAME
          - pattern-inside: |
              $METHOD(...) {
                ...
                Paths.get($VAR);
                ...
              }
      - pattern-not-inside: |
          if ($FILENAME.contains("..") || $FILENAME.startsWith("/")) {
              throw ...;
          }
      - pattern-not-inside: |
          String $SAFE_NAME = Paths.get($FILENAME).getFileName().toString();
          ...
    metadata:
      category: path-traversal
      cwe: CWE-22
      solution: |
        Validate and sanitize file paths to prevent directory traversal:
        
        // Instead of:
        String fullPath = BASE_DIR + filename;
        Files.readString(Paths.get(fullPath));
        
        // Use:
        Path basePath = Paths.get(BASE_DIR).normalize();
        Path requestedPath = basePath.resolve(filename).normalize();
        if (!requestedPath.startsWith(basePath)) {
            throw new SecurityException("Path traversal attempt");
        }
        Files.readString(requestedPath);

  - id: java-taint-multipart-to-file
    message: 'Taint flow: Multipart filename reaches file operation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Pattern for method parameter (matches your code)
          - patterns:
              - pattern-inside: |
                  $RETURN_TYPE $METHOD(..., MultipartFile $FILE, ...) {
                    ...
                  }
              - pattern-inside: |
                  String $NAME = $FILE.getOriginalFilename();
                  ...
              - pattern: new File($PATH + $NAME)
          # Pattern for variable assignment
          - patterns:
              - pattern-inside: |
                  MultipartFile $FILE = ...;
                  ...
                  String $NAME = $FILE.getOriginalFilename();
                  ...
              - pattern: new File($PATH + $NAME)
    metadata:
      category: path-traversal
      cwe: CWE-22
      taint_flow: true
      solution: |
        Validate and sanitize filenames to prevent path traversal attacks:
        
        // Instead of:
        MultipartFile file = request.getFile("upload");
        String filename = file.getOriginalFilename();
        File dest = new File("/uploads/" + filename);
        
        // Use:
        MultipartFile file = request.getFile("upload");
        String originalName = file.getOriginalFilename();
        String safeFilename = Paths.get(originalName).getFileName().toString();
        if (!safeFilename.matches("[a-zA-Z0-9._-]+")) {
            throw new IllegalArgumentException("Invalid filename");
        }
        File dest = new File("/uploads/" + safeFilename);

  - id: java-servlet-resource-path-traversal
    message: 'Path traversal vulnerability: ServletContext.getResourceAsStream() with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $PATH = $REQUEST.getParameter(...);
              ...
          - pattern: $CONTEXT.getResourceAsStream("/resources/" + $PATH)
          - pattern-not-inside: |
              if ($PATH.contains("..") || $PATH.contains("/")) {
                ...
              }
          - pattern-not-inside: |
              Set<String> $ALLOWED = ...;
              if ($ALLOWED.contains($PATH)) {
                ...
              }
    metadata:
      category: path-traversal
      cwe: CWE-22
      solution: |
        Validate and sanitize resource paths to prevent path traversal:
        
        // Instead of:
        String resourcePath = request.getParameter("resource");
        InputStream stream = servletContext.getResourceAsStream("/resources/" + resourcePath);
        
        // Use:
        String resourceName = request.getParameter("resource");
        if (resourceName.contains("..") || resourceName.contains("/")) {
            throw new IllegalArgumentException("Invalid resource name");
        }
        Set<String> allowedResources = Set.of("config.properties", "template.html");
        if (allowedResources.contains(resourceName)) {
            InputStream stream = servletContext.getResourceAsStream("/resources/" + resourceName);
        }

  - id: java-file-reader-path-traversal
    message: 'Path traversal vulnerability: User input in FileReader'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: new FileReader($PATH + ...)
          - pattern: new FileReader(... + $VAR)
          - pattern: new FileReader(... + $VAR + ...)
    metadata:
      category: path-traversal
      cwe: CWE-22
      solution: |
        Validate and sanitize file paths to prevent directory traversal:
        
        // Instead of:
        String userFile = request.getParameter("file");
        FileReader reader = new FileReader("/data/" + userFile);
        
        // Use:
        String userFile = request.getParameter("file");
        
        // Validate filename
        String safeFilename = Paths.get(userFile).getFileName().toString();
        if (safeFilename.contains("..") || !safeFilename.matches("[a-zA-Z0-9._-]+")) {
            throw new IllegalArgumentException("Invalid filename");
        }
        
        Path safePath = Paths.get("/data").resolve(safeFilename);
        if (!safePath.normalize().startsWith("/data")) {
            throw new IllegalArgumentException("Path traversal attempt");
        }
        
        FileReader reader = new FileReader(safePath.toFile());

  - id: java-file-writer-path-traversal
    message: 'Path traversal vulnerability: User input in FileWriter'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: new FileWriter($PATH + ...)
          - pattern: new FileWriter(... + $VAR)
          - pattern: new FileWriter(... + $VAR + ...)
    metadata:
      category: path-traversal
      cwe: CWE-22
      solution: |
        Validate file paths and use secure base directories:
        
        // Instead of:
        String userPath = request.getParameter("path");
        FileWriter writer = new FileWriter("/output/" + userPath);
        
        // Use:
        String userFilename = request.getParameter("filename");
        
        // Sanitize and validate filename
        String safeFilename = Paths.get(userFilename).getFileName().toString();
        if (!safeFilename.matches("[a-zA-Z0-9._-]+")) {
            throw new IllegalArgumentException("Invalid filename");
        }
        
        Path outputPath = Paths.get("/secure/output").resolve(safeFilename);
        if (!outputPath.normalize().startsWith("/secure/output")) {
            throw new SecurityException("Invalid output path");
        }
        
        FileWriter writer = new FileWriter(outputPath.toFile());

  - id: java-zip-slip-vulnerability
    message: 'Zip Slip vulnerability: Unsafe zip entry extraction without path validation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: new File($EXTRACT_DIR, $ENTRY.getName())
      - pattern-inside: |
          while (($ENTRY = $ZIS.getNextEntry()) != null) {
            ...
          }
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            if ($NAME.contains("..") || ...) {
              throw ...;
            }
            ...
          }
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            if (!$CANONICAL_PATH.startsWith($CANONICAL_EXTRACT_DIR)) {
              throw ...;
            }
            ...
          }
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            String $CANONICAL_PATH = $FILE.getCanonicalPath();
            String $CANONICAL_EXTRACT_DIR = $EXTRACT_DIR.getCanonicalPath();
            if (!$CANONICAL_PATH.startsWith($CANONICAL_EXTRACT_DIR)) {
              throw ...;
            }
            ...
          }
    metadata:
      category: path-traversal
      cwe: CWE-22
      solution: |
        Validate zip entry paths to prevent directory traversal attacks:
        
        // Instead of:
        while ((entry = zis.getNextEntry()) != null) {
            File file = new File(extractDir, entry.getName());
            // ... extract file
        }
        
        // Use:
        while ((entry = zis.getNextEntry()) != null) {
            String entryName = entry.getName();
            
            // Basic path validation
            if (entryName.contains("..") || entryName.startsWith("/")) {
                throw new IllegalArgumentException("Unsafe zip entry: " + entryName);
            }
            
            File file = new File(extractDir, entryName);
            
            // Canonical path validation
            String canonicalPath = file.getCanonicalPath();
            String canonicalExtractDir = extractDir.getCanonicalPath();
            if (!canonicalPath.startsWith(canonicalExtractDir)) {
                throw new IllegalArgumentException("Zip slip attempt: " + entryName);
            }
            
            // ... safely extract file
        }

  # ===========================================================================
  # 4. XML/XXE VULNERABILITIES
  # ===========================================================================

  - id: java-xmlinputfactory-xxe
    message: 'XXE vulnerability: XMLInputFactory without external entity protection'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern: XMLInputFactory $FACTORY = XMLInputFactory.newInstance();
          - pattern-not-inside: |
              XMLInputFactory $FACTORY = XMLInputFactory.newInstance();
              $FACTORY.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    metadata:
      category: xml-xxe
      cwe: CWE-611
      solution: |
        Configure XMLInputFactory to disable external entities and DTD processing:
        
        // Instead of:
        XMLInputFactory factory = XMLInputFactory.newInstance();
        
        // Use:
        XMLInputFactory factory = XMLInputFactory.newInstance();
        factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);

  - id: java-jdom2-xxe
    message: 'XXE vulnerability: JDOM2 SAXBuilder without XXE protection'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              SAXBuilder $BUILDER = new SAXBuilder();
              ...
          - pattern: $BUILDER.build($INPUT)
          - pattern-not-inside: |
              $BUILDER.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
              ...
          - pattern-not-inside: |
              $BUILDER.setFeature("http://xml.org/sax/features/external-general-entities", false);
              ...
    metadata:
      category: xml-xxe
      cwe: CWE-611
      library: jdom2
      solution: |
        Configure SAXBuilder to disable external entity processing:
        
        // Instead of:
        SAXBuilder builder = new SAXBuilder();
        Document doc = builder.build(inputStream);
        
        // Use:
        SAXBuilder builder = new SAXBuilder();
        builder.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        builder.setFeature("http://xml.org/sax/features/external-general-entities", false);
        builder.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        Document doc = builder.build(inputStream);

  - id: java-stax-xxe
    message: 'XXE vulnerability: StAX parser without external entity protection'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern: XMLInputFactory $FACTORY = XMLInputFactory.newFactory();
          - pattern-inside: |
              XMLInputFactory $FACTORY = XMLInputFactory.newFactory();
              ...
              XMLStreamReader $READER = $FACTORY.createXMLStreamReader($INPUT);
          - pattern-not-inside: |
              XMLInputFactory $FACTORY = XMLInputFactory.newFactory();
              $FACTORY.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
              ...
          - pattern-not-inside: |
              XMLInputFactory $FACTORY = XMLInputFactory.newFactory();
              $FACTORY.setProperty(XMLInputFactory.SUPPORT_DTD, false);
              ...
    metadata:
      category: xml-xxe
      cwe: CWE-611
      solution: |
        Configure XMLInputFactory to disable external entity processing:
        
        // Instead of:
        XMLInputFactory factory = XMLInputFactory.newFactory();
        XMLStreamReader reader = factory.createXMLStreamReader(inputStream);
        
        // Use:
        XMLInputFactory factory = XMLInputFactory.newFactory();
        factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);
        XMLStreamReader reader = factory.createXMLStreamReader(inputStream);

  - id: java-xxe-documentbuilder
    message: 'XXE vulnerability: DocumentBuilder without XXE protection'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          DocumentBuilderFactory $DBF = DocumentBuilderFactory.newInstance();
          ...
      - pattern: DocumentBuilder $DB = $DBF.newDocumentBuilder();
      - pattern-not-inside: |
          DocumentBuilderFactory $DBF = DocumentBuilderFactory.newInstance();
          ...
          $DBF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
          ...
      - pattern-not-inside: |
          DocumentBuilderFactory $DBF = DocumentBuilderFactory.newInstance();
          ...
          $DBF.setFeature("http://xml.org/sax/features/external-general-entities", false);
          ...
    metadata:
      category: xml-xxe
      cwe: CWE-611
      solution: |
        Configure DocumentBuilderFactory to disable external entity processing:
        
        // Instead of:
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        
        // Use:
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
        dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        dbf.setXIncludeAware(false);
        dbf.setExpandEntityReferences(false);
        DocumentBuilder db = dbf.newDocumentBuilder();

  - id: java-xxe-saxparser
    message: 'XXE vulnerability: SAXParser without XXE protection'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          SAXParserFactory $SPF = SAXParserFactory.newInstance();
          ...
      - pattern: SAXParser $SP = $SPF.newSAXParser();
      - pattern-not-inside: |
          SAXParserFactory $SPF = SAXParserFactory.newInstance();
          ...
          $SPF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
          ...
      - pattern-not-inside: |
          SAXParserFactory $SPF = SAXParserFactory.newInstance();
          ...
          $SPF.setFeature("http://xml.org/sax/features/external-general-entities", false);
          ...
    metadata:
      category: xml-xxe
      cwe: CWE-611
      solution: |
        Configure SAXParserFactory to disable external entity processing:
        
        // Instead of:
        SAXParserFactory spf = SAXParserFactory.newInstance();
        SAXParser sp = spf.newSAXParser();
        
        // Use:
        SAXParserFactory spf = SAXParserFactory.newInstance();
        spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        spf.setFeature("http://xml.org/sax/features/external-general-entities", false);
        spf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        spf.setXIncludeAware(false);
        SAXParser sp = spf.newSAXParser();

  - id: java-xxe-transformer
    message: 'XXE vulnerability: TransformerFactory without secure processing'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          TransformerFactory $TF = TransformerFactory.newInstance();
          ...
      - pattern: Transformer $T = $TF.newTransformer();
      - pattern-not-inside: |
          TransformerFactory $TF = TransformerFactory.newInstance();
          ...
          $TF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
          ...
      - pattern-not-inside: |
          TransformerFactory $TF = TransformerFactory.newInstance();
          ...
          $TF.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
          ...
    metadata:
      category: xml-xxe
      cwe: CWE-611
      solution: |
        Configure TransformerFactory to disable external entity processing:
        
        // Instead of:
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer transformer = tf.newTransformer();
        
        // Use:
        TransformerFactory tf = TransformerFactory.newInstance();
        tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
        Transformer transformer = tf.newTransformer();

  - id: java-xxe-xmlreader
    message: 'XXE vulnerability: XMLReader without XXE protection'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: XMLReader $READER = XMLReaderFactory.createXMLReader();
      - pattern-not-inside: |
          XMLReader $READER = XMLReaderFactory.createXMLReader();
          ...
          $READER.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
          ...
      - pattern-not-inside: |
          XMLReader $READER = XMLReaderFactory.createXMLReader();
          ...
          $READER.setFeature("http://xml.org/sax/features/external-general-entities", false);
          ...
    metadata:
      category: xml-xxe
      cwe: CWE-611
      solution: |
        Configure XMLReader to disable external entity processing:
        
        // Instead of:
        XMLReader reader = XMLReaderFactory.createXMLReader();
        
        // Use:
        XMLReader reader = XMLReaderFactory.createXMLReader();
        reader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        reader.setFeature("http://xml.org/sax/features/external-general-entities", false);
        reader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        reader.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);

  # ===========================================================================
  # 5. DESERIALIZATION VULNERABILITIES
  # ===========================================================================

  - id: java-kryo-unsafe-deserialization
    message: 'Deserialization vulnerability: Unsafe Kryo deserialization'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              Kryo $KRYO = new Kryo();
              ...
          - pattern: $KRYO.readObject($INPUT, ...)
          - pattern-not-inside: |
              $KRYO.setRegistrationRequired(true);
              ...
    metadata:
      category: deserialization
      cwe: CWE-502
      library: kryo
      solution: |
        Use Kryo with class registration and validation to restrict deserialization:
        
        // Instead of:
        Kryo kryo = new Kryo();
        Object obj = kryo.readObject(input, SomeClass.class);
        
        // Use:
        Kryo kryo = new Kryo();
        kryo.setRegistrationRequired(true);
        kryo.register(SomeClass.class);
        kryo.setReferences(false);
        Object obj = kryo.readObject(input, SomeClass.class);

  - id: java-commons-collections-deserialization
    message: 'Deserialization vulnerability: Apache Commons Collections gadget chain'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: new InvokerTransformer(...)
          - pattern: new InstantiateTransformer(...)
          - pattern: TransformedMap.decorate(..., ..., new InvokerTransformer(...))
    metadata:
      category: deserialization
      cwe: CWE-502
      library: commons-collections
      solution: |
        Avoid using InvokerTransformer and similar dangerous transformers with untrusted data:
        
        // Instead of:
        Transformer transformer = new InvokerTransformer("toString", null, null);
        Map transformedMap = TransformedMap.decorate(map, null, transformer);
        
        // Use:
        // Use standard Java collections or implement custom safe transformations
        Map<String, String> safeMap = new HashMap<>();
        for (Map.Entry<String, Object> entry : originalMap.entrySet()) {
            safeMap.put(entry.getKey(), String.valueOf(entry.getValue()));
        }

  - id: java-snakeyaml-constructor
    message: 'Deserialization vulnerability: SnakeYAML with unsafe constructor'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Direct chained calls
          - pattern: new Yaml().load($USER_INPUT)
          - pattern: new Yaml(new Constructor()).load($USER_INPUT)
          # Variable assignment then load (matches your code)
          - patterns:
              - pattern-inside: |
                  Yaml $YAML = new Yaml();
                  ...
              - pattern: $YAML.load($USER_INPUT)
          - patterns:
              - pattern-inside: |
                  Yaml $YAML = new Yaml(new Constructor());
                  ...
              - pattern: $YAML.load($USER_INPUT)
    metadata:
      category: deserialization
      cwe: CWE-502
      library: snakeyaml
      solution: |
        Use SafeConstructor and validate YAML structure:
        
        // Instead of:
        Yaml yaml = new Yaml();
        Object data = yaml.load(userInput);
        
        // Use:
        Yaml yaml = new Yaml(new SafeConstructor());
        Object data = yaml.load(userInput);
        
        // Or even better, use loadAs with specific class:
        MyConfig config = yaml.loadAs(userInput, MyConfig.class);

  - id: java-xstream-security-bypass
    message: 'Deserialization vulnerability: XStream security framework bypass'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $XSTREAM.addPermission(AnyTypePermission.ANY)
          - pattern: new XStream().fromXML($UNTRUSTED_XML)
    metadata:
      category: deserialization
      cwe: CWE-502
      library: xstream
      solution: |
        Configure XStream with strict permissions and allowlists:
        
        // Instead of:
        XStream xstream = new XStream();
        xstream.addPermission(AnyTypePermission.ANY);
        Object obj = xstream.fromXML(xml);
        
        // Use:
        XStream xstream = new XStream();
        xstream.addPermission(NoTypePermission.NONE);
        xstream.addPermission(new ExplicitTypePermission(new Class[]{MyClass.class}));
        Object obj = xstream.fromXML(xml);

  - id: java-commons-beanutils-deserialization
    message: 'Deserialization vulnerability: Apache Commons BeanUtils with untrusted input'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              Map $USER_MAP = (Map) $REQUEST.getAttribute(...);
              ...
          - pattern: BeanUtils.populate($BEAN, $USER_MAP)
    metadata:
      category: deserialization
      cwe: CWE-502
      library: commons-beanutils
      solution: |
        Validate property names against allowlists before using BeanUtils:
        
        // Instead of:
        Map userProps = (Map) request.getAttribute("properties");
        BeanUtils.populate(bean, userProps);
        
        // Use:
        Map userProps = (Map) request.getAttribute("properties");
        Set<String> allowedProps = Set.of("name", "email", "age");
        Map<String, Object> safeProps = new HashMap<>();
        for (String key : allowedProps) {
            if (userProps.containsKey(key)) {
                safeProps.put(key, userProps.get(key));
            }
        }
        BeanUtils.populate(bean, safeProps);

  - id: java-commons-serialization-deserialize
    message: 'Deserialization vulnerability: Commons SerializationUtils.deserialize()'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: SerializationUtils.deserialize($X)
    metadata:
      category: deserialization
      cwe: CWE-502
      library: commons-lang
      solution: |
        Avoid unsafe deserialization. Prefer safe data formats (JSON, XML).
        
        // Instead of:
        Object obj = SerializationUtils.deserialize(untrustedBytes);
        
        // Use:
        ObjectMapper mapper = new ObjectMapper();
        MyClass obj = mapper.readValue(jsonString, MyClass.class);
        
        // If binary serialization is unavoidable, validate classes with ObjectInputFilter

  - id: java-jackson-unsafe-deserialization-v2
    message: 'Deserialization vulnerability: Unsafe Jackson ObjectMapper usage with generic types'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $MAPPER.readValue($USER_INPUT, Object.class)
          - pattern: new ObjectMapper().readValue($USER_INPUT, Object.class)
          - pattern: $MAPPER.readValue($USER_INPUT, Map.class)
          - pattern: $MAPPER.readValue($USER_INPUT, List.class)
    metadata:
      category: deserialization
      cwe: CWE-502
      library: jackson
      solution: |
        Configure Jackson ObjectMapper with security features enabled:
        
        // Instead of:
        ObjectMapper mapper = new ObjectMapper();
        Object obj = mapper.readValue(userJson, Object.class);
        
        // Use:
        MyClass obj = mapper.readValue(userJson, MyClass.class);

  # ===========================================================================
  # 6. SSRF (SERVER-SIDE REQUEST FORGERY)
  # ===========================================================================

  - id: java-spring-resttemplate-ssrf-v2
    message: 'SSRF vulnerability: User input in RestTemplate URL'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $REST_TEMPLATE.getForObject($USER_URL, ...)
          - pattern: $REST_TEMPLATE.getForObject($USER_URL + ..., ...)
          - pattern: $REST_TEMPLATE.exchange($USER_URL, ...)
          - pattern: $REST_TEMPLATE.exchange($USER_URL + ..., ...)
          - pattern: $REST_TEMPLATE.postForObject($USER_URL, ...)
          - pattern: $REST_TEMPLATE.postForObject($USER_URL + ..., ...)
      - pattern-not-inside: |
          String $VAR = $ALLOWED_MAP.get($ENDPOINT);
          ...
    metadata:
      category: ssrf
      cwe: CWE-918
      framework: spring
      solution: |
        Validate URLs and use allowlisted destinations:
        
        // Instead of:
        String userUrl = request.getParameter("url");
        String response = restTemplate.getForObject(userUrl, String.class);
        
        // Use:
        String endpoint = request.getParameter("endpoint");
        Map<String, String> allowedEndpoints = Map.of(
            "users", "https://api.trusted.com/users",
            "orders", "https://api.trusted.com/orders"
        );
        
        String url = allowedEndpoints.get(endpoint);
        if (url == null) {
            throw new IllegalArgumentException("Invalid endpoint");
        }
        
        String response = restTemplate.getForObject(url, String.class);

  - id: java-socket-ssrf
    message: "SSRF vulnerability: User-controlled socket connection"
    languages:
      - java
    severity: ERROR
    patterns:
      # Match user input directly passed to Socket constructor
      - pattern: |
          String $VAR = ServletActionContext.getRequest().getParameter(...);
          ...
          Socket $SOCKET = new Socket($VAR, ...);
      # Skip methods with allowlist validation
      - pattern-not-inside: |
          public $TYPE $METHOD(...) {
            ...
            Set<String> allowedHosts = ...;
            ...
          }
    metadata:
      category: ssrf
      cwe: "CWE-918"
      solution: |
        Validate destination hosts and block internal networks:
        
        // Instead of:
        String userHost = request.getParameter("host");
        Socket socket = new Socket(userHost, 80);
        
        // Use:
        String userHost = request.getParameter("host");
        
        // Block internal/private IPs (critical for SSRF)
        if (userHost.equals("localhost") || userHost.equals("127.0.0.1") || 
            userHost.startsWith("127.") || userHost.startsWith("192.168.") || 
            userHost.startsWith("10.") || userHost.startsWith("172.16.") ||
            userHost.startsWith("169.254.")) {
            throw new IllegalArgumentException("Internal hosts not allowed");
        }
        
        // Validate against allowlist
        Set<String> allowedHosts = Set.of("api.trusted.com", "service.partner.com");
        if (!allowedHosts.contains(userHost)) {
            throw new IllegalArgumentException("Host not allowed");
        }
        
        Socket socket = new Socket(userHost, 80);

  - id: java-httpurlconnection-ssrf-direct
    message: "SSRF vulnerability: User-controlled URL in HttpURLConnection"
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          String $VAR = ServletActionContext.getRequest().getParameter(...);
          HttpURLConnection $CONN = (HttpURLConnection) new URL($VAR).openConnection();
    metadata:
      category: ssrf
      cwe: "CWE-918"
      solution: |
        Validate URLs and restrict to trusted hosts:
        
        // Instead of:
        String userUrl = request.getParameter("url");
        HttpURLConnection conn = (HttpURLConnection) new URL(userUrl).openConnection();
        
        // Use:
        String userUrl = request.getParameter("url");
        URL url = new URL(userUrl);
        
        if (!"https".equals(url.getProtocol())) {
            throw new IllegalArgumentException("Only HTTPS allowed");
        }

  - id: java-httpurlconnection-ssrf-userinput
    message: "SSRF vulnerability: User input in HttpURLConnection"
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          String $VAR = ServletActionContext.getRequest().getParameter(...);
          ...
          HttpURLConnection $CONN = (HttpURLConnection) new URL($VAR).openConnection();
      # Skip methods with allowlist validation
      - pattern-not-inside: |
          public $TYPE $METHOD(...) {
            ...
            Set<String> allowedHosts = ...;
            ...
          }
    metadata:
      category: ssrf
      cwe: "CWE-918"
      solution: |
        Validate URLs against allowlists and check protocols:
        
        // UNSAFE:
        String userUrl = request.getParameter("url");
        HttpURLConnection conn = (HttpURLConnection) new URL(userUrl).openConnection();
        
        // SAFE:
        String userUrl = request.getParameter("url");
        URL url = new URL(userUrl);
        
        if (!"https".equals(url.getProtocol())) {
            throw new IllegalArgumentException("Only HTTPS allowed");
        }
        
        Set<String> allowedHosts = Set.of("api.trusted.com", "service.partner.com");
        if (!allowedHosts.contains(url.getHost())) {
            throw new IllegalArgumentException("Host not allowed");
        }
        
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

  - id: java-apache-httpclient-ssrf-taint
    message: 'SSRF vulnerability: User-controlled data used in HTTP client request without validation.'
    languages:
      - java
    severity: ERROR
    mode: taint
    pattern-sources:
      - pattern: request.getParameter(...)
      - pattern: request.getHeader(...)
      - pattern: request.getAttribute(...)
    pattern-sanitizers:
      - pattern: $MAP.get(...)
      - pattern: $SET.contains($VAR)
      - pattern: |
          if (!$ALLOWLIST.containsKey($VAR)) {
              ...
          }
      - pattern: |
          if ($ALLOWLIST.get($VAR) == null) {
              ...
          }
    pattern-sinks:
      - pattern: $CLIENT.execute(new HttpGet($...SINK))
      - pattern: $CLIENT.execute(new HttpPost($...SINK))
      - pattern: $CLIENT.execute(new HttpPut($...SINK))
      - pattern: $CLIENT.execute(new HttpDelete($...SINK))
    metadata:
      category: ssrf
      cwe: CWE-918
      library: apache-httpclient
      solution: |
        Validate URLs and implement allowlists for HTTP requests:
        
        // Instead of:
        String userUrl = request.getParameter("url");
        HttpGet httpGet = new HttpGet(userUrl);
        CloseableHttpResponse response = httpClient.execute(httpGet);
        
        // Use allowlist validation:
        String endpoint = request.getParameter("endpoint");
        Map<String, String> allowedEndpoints = Map.of(
            "api", "https://api.trusted.com/v1/",
            "webhook", "https://webhook.partner.com/"
        );
        
        String baseUrl = allowedEndpoints.get(endpoint);
        if (baseUrl == null) {
            throw new IllegalArgumentException("Invalid endpoint");
        }
        
        HttpGet httpGet = new HttpGet(baseUrl + "data");
        CloseableHttpResponse response = httpClient.execute(httpGet);

  - id: java-okhttp-ssrf
    message: 'SSRF vulnerability: User input used directly in OkHttp URL'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          String $VAR = request.getParameter(...);
          Request $REQ = new Request.Builder().url($VAR).build();
    metadata:
      category: ssrf
      cwe: CWE-918
      library: okhttp
      solution: |
        Use allowlist validation for URLs:
        
        // BAD:
        String userUrl = request.getParameter("url");
        Request req = new Request.Builder().url(userUrl).build();
        
        // GOOD:
        String endpoint = request.getParameter("endpoint");
        Map<String, String> allowedUrls = Map.of(
            "weather", "https://api.weather.com/v1/current"
        );
        String url = allowedUrls.get(endpoint);
        if (url == null) throw new IllegalArgumentException("Invalid endpoint");
        Request req = new Request.Builder().url(url).build();

  # ===========================================================================
  # 7. TEMPLATE/EXPRESSION INJECTION
  # ===========================================================================

  - id: java-spel-injection-direct
    message: 'SpEL injection vulnerability: User input in Spring Expression Language'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Direct usage: new SpelExpressionParser().parseExpression(userInput)
          - patterns:
              - pattern-inside: |
                  String $USER_INPUT = $REQUEST.getParameter(...);
                  ...
              - pattern-either:
                  - pattern: new SpelExpressionParser().parseExpression($USER_INPUT)
                  - pattern: new SpelExpressionParser().parseExpression($USER_INPUT + ...)
          # Variable parser usage: parser.parseExpression(userInput)
          - patterns:
              - pattern-inside: |
                  String $USER_INPUT = $REQUEST.getParameter(...);
                  ...
              - pattern-either:
                  - pattern: $PARSER.parseExpression($USER_INPUT)
                  - pattern: $PARSER.parseExpression($USER_INPUT + ...)
    metadata:
      category: template-injection
      cwe: CWE-94
      solution: |
        Avoid using user input directly in SpEL expressions, use predefined expressions:
        
        // Instead of:
        String userExpr = request.getParameter("expression");
        SpelExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression(userExpr);
        
        // Use:
        String operation = request.getParameter("operation");
        Map<String, String> allowedExpressions = Map.of(
            "multiply", "#value * 2",
            "add", "#value + 10"
        );
        if (allowedExpressions.containsKey(operation)) {
            Expression exp = parser.parseExpression(allowedExpressions.get(operation));
        }

  - id: java-spring-el-remote
    message: 'RCE vulnerability: Spring EL with remote expression'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $PARSER.parseExpression($USER_INPUT).getValue(...)
          - pattern: ExpressionParser.parseExpression("#{" + $USER_INPUT + "}")
    metadata:
      category: template-injection
      cwe: CWE-94
      framework: spring
      solution: |
        Use predefined expressions or validate input against allowlists:
        
        // Instead of:
        String userExpr = request.getParameter("expression");
        Expression exp = parser.parseExpression("#{" + userExpr + "}");
        
        // Use:
        String operation = request.getParameter("operation");
        Map<String, String> safeExpressions = Map.of(
            "double", "#{#value * 2}",
            "square", "#{#value * #value}"
        );
        if (safeExpressions.containsKey(operation)) {
            Expression exp = parser.parseExpression(safeExpressions.get(operation));
        }

  - id: java-el-injection
    message: 'Expression Language injection vulnerability'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: $FACTORY.createValueExpression($CONTEXT, $USER_INPUT, $CLASS)
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            Set<String> $ALLOWED = ...;
            if ($ALLOWED.contains($VAR)) {
              ...
            }
            ...
          }
    metadata:
      category: template-injection
      cwe: CWE-94
      framework: el
      solution: |
        Use predefined expressions and validate input against allowlists:
        
        // Instead of:
        String userExpr = request.getParameter("expression");
        ValueExpression ve = factory.createValueExpression(context, userExpr, String.class);
        
        // Use:
        String property = request.getParameter("property");
        Set<String> allowedProperties = Set.of("user.name", "user.email");
        
        if (allowedProperties.contains(property)) {
            ValueExpression ve = factory.createValueExpression(context, "#{" + property + "}", String.class);
        }

  - id: java-jsf-el-injection
    message: 'EL injection vulnerability: JSF expression with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              "#{" + $USER_INPUT + "}"
          - pattern: |
              FacesContext.getCurrentInstance().getApplication().evaluateExpressionGet(..., "#{" + $USER_INPUT + "}", ...)
    metadata:
      category: template-injection
      cwe: CWE-94
      framework: jsf
      solution: |
        Never concatenate user input into EL expressions, use data binding:
        
        // Instead of:
        String userExpr = request.getParameter("expression");
        String el = "#{" + userExpr + "}";
        
        // Use:
        // Set data in managed bean and reference safely
        @ManagedProperty("#{param.value}")
        private String userValue;
        // Then use #{bean.userValue} in EL expressions

  - id: java-template-injection-velocity
    message: 'Template injection vulnerability: User input in Velocity template'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $TEMPLATE = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: $VELOCITY.evaluate($CONTEXT, $WRITER, $LOG_TAG, $TEMPLATE)
              - pattern: $VELOCITY.evaluate($CONTEXT, $WRITER, $TEMPLATE, ...)
              - pattern: $VELOCITY.evaluate($CONTEXT, $WRITER, $TEMPLATE)
    metadata:
      category: template-injection
      cwe: CWE-94
      solution: |
        Use predefined templates and validate template names:
        
        // Instead of:
        String userTemplate = request.getParameter("template");
        velocity.evaluate(context, writer, "log", userTemplate);
        
        // Use:
        String templateName = request.getParameter("templateName");
        Set<String> allowedTemplates = Set.of("welcome", "confirmation");
        if (allowedTemplates.contains(templateName)) {
            Template template = velocity.getTemplate(templateName + ".vm");
            template.merge(context, writer);
        }

  - id: java-template-injection-freemarker
    message: 'Template injection vulnerability: User input in FreeMarker template'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - patterns:
              - pattern: new Template($NAME, $USER_INPUT, $CFG)
              - pattern-not-inside: |
                  $METHOD(...) {
                    ...
                    Set<String> $ALLOWED = ...;
                    if ($ALLOWED.contains($VAR)) {
                      ...
                    }
                    ...
                  }
          - patterns:
              - pattern: new Template($NAME, $USER_INPUT, $CFG, ...)
              - pattern-not-inside: |
                  $METHOD(...) {
                    ...
                    Set<String> $ALLOWED = ...;
                    if ($ALLOWED.contains($VAR)) {
                      ...
                    }
                    ...
                  }
    metadata:
      category: template-injection
      cwe: CWE-94
      solution: |
        Use predefined FreeMarker templates and validate template sources:
        
        // Instead of:
        String userTemplate = request.getParameter("template");
        Template template = new Template("user", userTemplate, cfg);
        
        // Use:
        String templateName = request.getParameter("templateName");
        Set<String> allowedTemplates = Set.of("email", "report", "invoice");
        if (allowedTemplates.contains(templateName)) {
            Template template = cfg.getTemplate(templateName + ".ftl");
            template.process(dataModel, writer);
        }

  # ===========================================================================
  # 8. INFORMATION DISCLOSURE
  # ===========================================================================

  - id: java-session-sensitive-data-storage
    message: 'Information disclosure: Sensitive data stored in HTTP session'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $SESSION.setAttribute("password", $PASSWORD)
          - pattern: $SESSION.setAttribute("secret", $SECRET)
          - pattern: $SESSION.setAttribute("token", $TOKEN)
          - pattern: $SESSION.setAttribute("apiKey", $KEY)
          - pattern: $SESSION.setAttribute("privateKey", $KEY)
          - pattern: $SESSION.setAttribute("creditCard", $CC)
          - pattern: $SESSION.setAttribute("ssn", $SSN)
    metadata:
      category: information-disclosure
      cwe: CWE-200
      solution: |
        Store only non-sensitive session identifiers, keep sensitive data server-side:
        
        // Instead of:
        session.setAttribute("password", userPassword);
        session.setAttribute("creditCard", cardNumber);
        
        // Use:
        // Store only session ID, keep sensitive data in secure storage
        String sessionId = UUID.randomUUID().toString();
        session.setAttribute("userId", userId);
        // Store sensitive data in encrypted database or secure cache
        secureStorage.store(sessionId, encryptedSensitiveData);

  - id: java-system-property-sensitive-exposure
    message: 'Information disclosure: Sensitive system property exposure'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-either:
              - pattern: System.getProperty("java.class.path")
              - pattern: System.getProperty("java.home")  
              - pattern: System.getProperty("user.dir")
              - pattern: System.getProperty("user.home")
              - pattern: System.getProperty("java.library.path")
          - pattern-inside: |
              $METHOD(...) {
                ...
                $RESPONSE.getWriter().write(...);
              }
          - pattern-not-inside: |
              if ($USER.hasRole(...)) {
                ...
              }
          - pattern-not-inside: |
              if ($AUTH_CHECK) {
                ...
              }
    metadata:
      category: information-disclosure
      cwe: CWE-200
      solution: |
        Avoid exposing sensitive system properties or protect with proper authorization:
        
        // Instead of:
        String classpath = System.getProperty("java.class.path");
        response.getWriter().write("Classpath: " + classpath);
        
        // Use:
        String appVersion = System.getProperty("app.version", "unknown");
        response.getWriter().write("Application version: " + appVersion);
        
        // Or protect sensitive properties with authorization:
        if (user.hasRole("ADMIN")) {
            String osName = System.getProperty("os.name");
            response.getWriter().write("OS: " + osName);
        }

  - id: java-server-info-disclosure
    message: 'Information disclosure: Server technology information exposed'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-either:
          - patterns:
              - pattern: $RESPONSE.setHeader("Server", $VALUE)
              - metavariable-regex:
                  metavariable: $VALUE
                  regex: '.*[0-9]+\.[0-9]+.*|.*Apache.*|.*nginx.*|.*IIS.*|.*Tomcat.*'
          - patterns:
              - pattern: $RESPONSE.addHeader("X-Powered-By", $VALUE)
              - metavariable-regex:
                  metavariable: $VALUE
                  regex: '.*[0-9]+\.[0-9]+.*|.*PHP.*|.*Java.*|.*ASP\.NET.*'
          - pattern: $RESPONSE.setHeader("Server", "Apache/$VERSION")
          - pattern: $RESPONSE.addHeader("X-Powered-By", "Java/$VERSION")
    metadata:
      category: information-disclosure
      cwe: CWE-200
      solution: |
        Remove or obfuscate server information headers:
        
        // Instead of:
        response.setHeader("Server", "Apache/2.4.41");
        response.addHeader("X-Powered-By", "Java/11");
        
        // Use:
        response.setHeader("Server", "GenericServer");
        // Or better: configure server to suppress headers entirely
        
        // In web.xml for servlet containers:
        // <filter>
        //   <filter-name>HiddenHttpMethodFilter</filter-name>
        //   <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
        // </filter>

  - id: java-debug-endpoint-exposed
    message: 'Information disclosure: Debug endpoint without proper access control'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          @GetMapping("/debug/status")
          public $TYPE $METHOD(...) {
            ...
          }
      - pattern-not-inside: |
          $METHOD(..., Authentication $AUTH, ...) {
            ...
            if (!$AUTH.getAuthorities().contains(...)) {
              throw ...;
            }
            ...
          }
    metadata:
      category: information-disclosure
      cwe: CWE-200
      framework: spring
      solution: |
        Add proper authorization to debug endpoints:
        
        // Instead of:
        @GetMapping("/debug/status")
        public String badDebugStatus() {
            return "Debug info here";
        }
        
        // Use annotation-based:
        @PreAuthorize("hasRole('ADMIN')")
        @GetMapping("/debug/status")
        public String goodDebugStatus() {
            return "Debug info here";
        }
        
        // Or programmatic check:
        @GetMapping("/debug/status")
        public String goodDebugStatus(Authentication auth) {
            if (!auth.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
                throw new AccessDeniedException("Admin access required");
            }
            return "Debug info here";
        }

  # ===========================================================================
  # 9. CRYPTOGRAPHY
  # ===========================================================================

  - id: java-weak-encryption-blowfish
    message: 'Weak cryptography: Blowfish encryption algorithm is outdated'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: Cipher.getInstance("Blowfish")
          - pattern: Cipher.getInstance("Blowfish/...")
    metadata:
      category: cryptography
      cwe: CWE-327
      solution: |
        Replace Blowfish with modern encryption algorithms like AES:
        
        // Instead of:
        Cipher cipher = Cipher.getInstance("Blowfish");
        
        // Use:
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        // Or for CBC mode with proper IV:
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

  - id: java-hardcoded-crypto-key
    message: 'Cryptographic flaw: Hardcoded encryption key'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              byte[] $KEY = { ... };
              SecretKeySpec $SPEC = new SecretKeySpec($KEY, ...);
          - pattern: new SecretKeySpec("...".getBytes(), ...)
    metadata:
      category: cryptography
      cwe: CWE-798
      solution: |
        Use environment variables or secure key management for encryption keys:
        
        // Instead of:
        byte[] key = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        
        // Use:
        String keyString = System.getenv("ENCRYPTION_KEY");
        if (keyString == null) {
            throw new IllegalStateException("Encryption key not configured");
        }
        byte[] key = Base64.getDecoder().decode(keyString);
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");

  - id: java-insecure-key-derivation
    message: 'Weak cryptography: Insufficient PBKDF2 iterations'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern: new PBEKeySpec(..., ..., $ITERATIONS, ...)
          - metavariable-comparison:
              metavariable: $ITERATIONS
              comparison: $ITERATIONS < 10000
    metadata:
      category: cryptography
      cwe: CWE-326
      solution: |
        Use sufficient iterations for PBKDF2 key derivation:
        
        // Instead of:
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 100, 256);
        
        // Use:
        int iterations = 100000; // At least 10,000, preferably 100,000+
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, 256);

  - id: java-password-hash-no-salt
    message: 'Cryptographic flaw: Password hashing without proper salt'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              MessageDigest $MD = MessageDigest.getInstance(...);
              $MD.digest($PASSWORD.getBytes());
          - pattern: BCrypt.hashpw($PASSWORD, "...")
    metadata:
      category: cryptography
      cwe: CWE-759
      solution: |
        Use proper salted password hashing with BCrypt or similar:
        
        // Instead of:
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] hash = md.digest(password.getBytes());
        
        // Use:
        // Generate random salt for each password
        String salt = BCrypt.gensalt(12);
        String hashedPassword = BCrypt.hashpw(password, salt);
        
        // Or use Spring Security's PasswordEncoder:
        PasswordEncoder encoder = new BCryptPasswordEncoder(12);
        String hashedPassword = encoder.encode(password);

  - id: java-hardcoded-salt
    message: 'Cryptographic flaw: Hardcoded or weak salt in password hashing'
    languages:
      - java
    severity: ERROR
    patterns:
    - pattern-either:
        - pattern: '"salt".getBytes()'
        - pattern: '"password".getBytes()'
        - pattern: '"key".getBytes()'
        - pattern: '"secret".getBytes()'
    metadata:
      category: cryptography
      cwe: CWE-760
      solution: |
        Generate random salts for password hashing:
        
        // Instead of:
        byte[] salt = "salt".getBytes();
        
        // Use:
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        random.nextBytes(salt);

  - id: java-weak-key-generation-random
    message: 'Cryptographic flaw: Weak random number generator for key generation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: $RAND.nextBytes($KEY)
      - pattern-inside: |
          Random $RAND = new Random();
          ...
    metadata:
      category: cryptography
      cwe: CWE-330
      solution: |
        Use SecureRandom for cryptographic key generation:
        
        // Instead of:
        Random rand = new Random();
        byte[] key = new byte[16];
        rand.nextBytes(key);
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        
        // Use:
        SecureRandom secureRand = new SecureRandom();
        byte[] key = new byte[32]; // 256-bit key
        secureRand.nextBytes(key);
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");

  - id: java-certificate-validation-bypass
    message: 'SSL/TLS vulnerability: Certificate hostname verification disabled'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          HttpsURLConnection $CONN = ...;
          $CONN.setHostnameVerifier(($HOSTNAME, $SESSION) -> true);
    metadata:
      category: cryptography
      cwe: CWE-295
      solution: |
        Use proper hostname verification or implement custom secure verification:
        
        // Instead of:
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        conn.setHostnameVerifier((hostname, session) -> true);
        
        // Use:
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        // Use default hostname verifier (recommended)
        // conn.setHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());
        
        // Or implement secure custom verification:
        conn.setHostnameVerifier((hostname, session) -> {
            return HttpsURLConnection.getDefaultHostnameVerifier().verify(hostname, session);
        });

  - id: java-jwt-none-algorithm
    message: 'JWT security flaw: ''none'' algorithm allows token forgery'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: Algorithm.none()
          - pattern: JWTVerifier.init(Algorithm.none())
    metadata:
      category: cryptography
      cwe: CWE-327
      solution: |
        Use proper signing algorithms instead of 'none':
        
        // Instead of:
        Algorithm algorithm = Algorithm.none();
        JWTVerifier verifier = JWT.require(algorithm).build();
        
        // Use:
        String secret = System.getenv("JWT_SECRET");
        Algorithm algorithm = Algorithm.HMAC256(secret);
        JWTVerifier verifier = JWT.require(algorithm).build();
        
        // Or for RSA:
        RSAPublicKey publicKey = loadPublicKey();
        Algorithm algorithm = Algorithm.RSA256(publicKey, null);

  - id: java-jwt-algorithm-confusion
    message: 'JWT vulnerability: Algorithm confusion attack possible'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              JWTVerifier $VERIFIER = JWT.require($ALG).build();
              $VERIFIER.verify($TOKEN);
          - pattern: JWT.require($ALG).build().verify($TOKEN)
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            if (!$EXPECTED_ALG.equals($JWT.getAlgorithm())) {
              throw ...;
            }
            ...
          }
    metadata:
      category: cryptography
      cwe: CWE-347
      solution: |
        Explicitly specify and validate JWT algorithm during verification:
        
        // Instead of:
        Algorithm alg = Algorithm.HMAC256(secret);
        JWTVerifier verifier = JWT.require(alg).build();
        
        // Use:
        DecodedJWT jwt = JWT.decode(token);
        String expectedAlg = "HS256";
        if (!expectedAlg.equals(jwt.getAlgorithm())) {
            throw new JWTVerificationException("Invalid algorithm");
        }
        
        Algorithm alg = Algorithm.HMAC256(secret);
        JWTVerifier verifier = JWT.require(alg).withIssuer("expected-issuer").build();

  - id: java-jwt-hardcoded-secret
    message: 'JWT security flaw: Hardcoded JWT signing secret'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: Algorithm.HMAC256("...")
          - pattern: Algorithm.HMAC512("...")
    metadata:
      category: cryptography
      cwe: CWE-798
      solution: |
        Use environment variables or secure key management for JWT secrets:
        
        // Instead of:
        Algorithm algorithm = Algorithm.HMAC256("hardcoded-secret");
        
        // Use:
        String secret = System.getenv("JWT_SECRET");
        if (secret == null) {
            throw new IllegalStateException("JWT secret not configured");
        }
        Algorithm algorithm = Algorithm.HMAC256(secret);
        
        // Or use RSA keys for better security:
        RSAPublicKey publicKey = loadPublicKey();
        RSAPrivateKey privateKey = loadPrivateKey();
        Algorithm algorithm = Algorithm.RSA256(publicKey, privateKey);

  # ===========================================================================
  # 10. AUTHENTICATION/AUTHORIZATION
  # ===========================================================================

  - id: java-privilege-escalation-parameter
    message: 'Privilege escalation: User role set from request parameter'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          String $ROLE = request.getParameter("role");
          ...
      - pattern: $USER.setRole($ROLE)
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            if ($AUTH.getAuthorities().contains(...)) {
              ...
            }
            ...
          }
    metadata:
      category: authentication-authorization
      cwe: CWE-269
      solution: |
        Set user roles through proper authorization mechanisms, not request parameters:
        
        // Instead of:
        String role = request.getParameter("role");
        user.setRole(role);
        
        // Use:
        // Determine role through authentication and authorization
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
            user.setRole("ADMIN");
        } else {
            user.setRole("USER");
        }

  - id: java-admin-function-exposed
    message: 'Authorization flaw: Administrative endpoint without proper access control'  
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          @RequestMapping("/admin/users")
          public List<String> $METHOD() {
            ...
          }
      - pattern-not: |
          @PreAuthorize(...)
          @RequestMapping("/admin/users")
          public List<String> $METHOD() {
            ...
          }
    metadata:
      category: authentication-authorization
      cwe: CWE-862
      framework: spring
      solution: |
          Add proper authorization checks to administrative endpoints:
          
          // Instead of:
          @RequestMapping("/admin/users")
          public List<User> getAllUsers() {
              return userService.findAll();
          }
          
          // Use:
          @PreAuthorize("hasRole('ADMIN')")
          @RequestMapping("/admin/users")
          public List<User> getAllUsers() {
              return userService.findAll();
          }

  - id: java-spring-security-bypass
    message: 'Authorization bypass: Role check based on user-controlled parameter'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          @RequestMapping(...)
          public $TYPE $METHOD(HttpServletRequest request, ...) {
            ...
          }
      - pattern-inside: |
          String $ROLE = request.getParameter("role");
          ...
      - pattern: |
          if ($ROLE.equals("admin")) {
            ...
          }
    metadata:
      category: authentication-authorization
      cwe: CWE-862
      framework: spring
      solution: |
        Use Spring Security annotations for proper authorization:
        
        // Instead of:
        @RequestMapping("/admin/action")
        public String adminAction(HttpServletRequest request) {
            String role = request.getParameter("role");
            if (role.equals("admin")) {
                // admin logic
            }
        }
        
        // Use:
        @PreAuthorize("hasRole('ADMIN')")
        @RequestMapping("/admin/action")
        public String adminAction() {
            // admin logic - automatically protected
        }
        
        // Or check authentication programmatically:
        @RequestMapping("/admin/action")
        public String adminAction(Authentication auth) {
            if (!auth.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
                throw new AccessDeniedException("Admin role required");
            }
        }

  - id: java-idor-resource-access
    message: "IDOR vulnerability: Resource access without ownership verification"
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          @RestController
          class $CLASS {
            ...
          }
      - pattern-either:
          # Direct return pattern
          - pattern: |
              @RequestMapping($PATH)
              public $TYPE $METHOD(@PathVariable Long id) {
                return userService.findById(id);
              }
          # Variable assignment pattern  
          - pattern: |
              @RequestMapping($PATH)
              public $TYPE $METHOD(@PathVariable Long id) {
                User user = userService.findById(id);
                ...
              }
          # With additional parameters but no Authentication
          - pattern: |
              @RequestMapping($PATH)
              public $TYPE $METHOD(@PathVariable Long id, $...PARAMS) {
                return userService.findById(id);
              }
      - metavariable-regex:
          metavariable: $PATH
          regex: '.*users/\{id\}.*'
      # Skip methods that have Authentication parameter (likely secure)
      - pattern-not: |
          @RequestMapping($PATH)
          public $TYPE $METHOD(@PathVariable Long id, Authentication $AUTH, ...) {
            ...
          }
      - pattern-not: |
          @RequestMapping($PATH)
          public $TYPE $METHOD(@PathVariable Long id, ..., Authentication $AUTH, ...) {
            ...
          }
    metadata:
      category: authentication-authorization
      cwe: "CWE-639"
      owasp: "A01:2021"
      solution: |
        Verify resource ownership before allowing access:
        
        // Instead of:
        @RequestMapping("/api/users/{id}")
        public User getUser(@PathVariable Long id) {
            return userService.findById(id);
        }
        
        // Use:
        @RequestMapping("/api/users/{id}")
        public User getUser(@PathVariable Long id, Authentication auth) {
            String currentUsername = auth.getName();
            User requestedUser = userService.findById(id);
            
            if (!requestedUser.getUsername().equals(currentUsername) && 
                !auth.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
                throw new AccessDeniedException("Cannot access other user's data");
            }
            
            return requestedUser;
        }

  # ===========================================================================
  # 11. INPUT VALIDATION
  # ===========================================================================

  - id: java-spring-requestbody-validation-missing
    message: 'Input validation flaw: @RequestBody without validation annotations'
    languages:
      - java
    severity: WARNING
    pattern: |
      @$ANNOTATION(...)
      public $TYPE $METHOD(@RequestBody $ENTITY $PARAM) {
        ...
      }
    pattern-not: |
      @$ANNOTATION(...)
      public $TYPE $METHOD(@Valid @RequestBody $ENTITY $PARAM) {
        ...
      }
    metadata:
      category: input-validation
      cwe: CWE-20
      framework: spring
      solution: |
        Add @Valid annotation to @RequestBody parameters:
        
        // Instead of:
        @PostMapping("/users")
        public void createUser(@RequestBody User user) {
        
        // Use:
        @PostMapping("/users")
        public void createUser(@Valid @RequestBody User user) {

  - id: java-session-attribute-without-validation
    message: 'Input validation flaw: Session attribute used without validation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          String $ATTR = (String) $SESSION.getAttribute(...);
          ...
      - pattern-either:
        - pattern: '"SELECT * FROM data WHERE role = ''" + $ATTR + "''"'
        - pattern: $STMT.executeQuery("..." + $ATTR + "...")
        - pattern: Class.forName($ATTR)
        - pattern: Runtime.getRuntime().exec($ATTR)
    metadata:
      category: input-validation
      cwe: CWE-20
      solution: |
        Always validate session attributes before using them:
        
        // Instead of:
        String role = (String) session.getAttribute("role");
        String sql = "SELECT * FROM data WHERE role = '" + role + "'";
        
        // Use:
        String role = (String) session.getAttribute("role");
        Set<String> allowedRoles = Set.of("user", "admin", "guest");
        if (role != null && allowedRoles.contains(role)) {
            PreparedStatement pstmt = connection.prepareStatement("SELECT * FROM data WHERE role = ?");
            pstmt.setString(1, role);
            ResultSet rs = pstmt.executeQuery();
        }

  - id: java-string-format-injection
    message: 'Format string vulnerability: User input controls String.format() pattern'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_FORMAT = $REQUEST.getParameter(...);
              ...
          - pattern: String.format($USER_FORMAT, ...)
    metadata:
      category: input-validation
      cwe: CWE-134
      solution: |
        Use predefined format strings instead of user-controlled formats:
        
        // Instead of:
        String userFormat = request.getParameter("format");
        String result = String.format(userFormat, data);
        
        // Use:
        String userData = request.getParameter("data");
        String result = String.format("User data: %s", userData);

  - id: java-simpledateformat-parse-dos
    message: 'DoS vulnerability: SimpleDateFormat with user-controlled pattern'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_PATTERN = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: new SimpleDateFormat($USER_PATTERN)
              - pattern: new java.text.SimpleDateFormat($USER_PATTERN)
    metadata:
      category: input-validation
      cwe: CWE-20
      solution: |
        Use DateTimeFormatter with predefined patterns instead of SimpleDateFormat:
        
        // Instead of:
        String userPattern = request.getParameter("pattern");
        SimpleDateFormat formatter = new SimpleDateFormat(userPattern);
        
        // Use:
        String userInput = request.getParameter("date");
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        LocalDate date = LocalDate.parse(userInput, formatter);

  - id: java-simpledateformat-format-injection
    message: 'Format injection: SimpleDateFormat with user-controlled pattern'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_PATTERN = $REQUEST.getParameter(...);
              ...
          - pattern: new SimpleDateFormat($USER_PATTERN)
    metadata:
      category: input-validation
      cwe: CWE-20
      solution: |
        Use allowlist validation or DateTimeFormatter with predefined patterns:
        
        // Instead of:
        String userPattern = request.getParameter("pattern");
        SimpleDateFormat formatter = new SimpleDateFormat(userPattern);
        
        // Use:
        Map<String, String> allowedFormats = Map.of(
            "short", "MM/dd/yy",
            "long", "MMM dd, yyyy",
            "iso", "yyyy-MM-dd"
        );
        String formatType = request.getParameter("format");
        if (allowedFormats.containsKey(formatType)) {
            SimpleDateFormat formatter = new SimpleDateFormat(allowedFormats.get(formatType));
        }

  - id: java-pattern-dos-compilation
    message: 'ReDoS vulnerability: User input in Pattern.compile()'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_REGEX = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: Pattern.compile($USER_REGEX)
              - pattern: $STRING.matches($USER_REGEX)
    metadata:
      category: input-validation
      cwe: CWE-1333
      solution: |
        Use predefined regex patterns instead of user-controlled input:
        
        // Instead of:
        String userRegex = request.getParameter("pattern");
        Pattern pattern = Pattern.compile(userRegex);
        
        // Use:
        String inputType = request.getParameter("type");
        Map<String, Pattern> patterns = Map.of(
            "email", Pattern.compile("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"),
            "phone", Pattern.compile("\\d{3}-\\d{3}-\\d{4}")
        );
        Pattern pattern = patterns.get(inputType);

  - id: java-number-format-dos
    message: 'DoS vulnerability: NumberFormat with unvalidated input'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $INPUT = $REQUEST.getParameter(...);
              ...
          - pattern: NumberFormat.getInstance().parse($INPUT)
          - pattern-not-inside: |
              if ($INPUT.length() > $LIMIT) {
                ...
              }
          - pattern-not-inside: |
              if (!$INPUT.matches(...)) {
                ...
              }
    metadata:
      category: input-validation
      cwe: CWE-20
      solution: |
        Validate input length and format before parsing numbers:
        
        // Instead of:
        String userNumber = request.getParameter("number");
        Number num = NumberFormat.getInstance().parse(userNumber);
        
        // Use:
        String userNumber = request.getParameter("number");
        if (userNumber.length() > 20 || !userNumber.matches("-?\\d+(\\.\\d+)?")) {
            throw new IllegalArgumentException("Invalid number format");
        }
        Number num = NumberFormat.getInstance().parse(userNumber);

  - id: java-locale-injection
    message: 'Locale injection: User-controlled locale creation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: new Locale($USER_LANGUAGE, $USER_COUNTRY)
          - pattern: Locale.forLanguageTag($USER_INPUT)
    metadata:
      category: input-validation
      cwe: CWE-20
      solution: |
        Validate locale parameters against supported locales:
        
        // Instead of:
        String userLang = request.getParameter("lang");
        String userCountry = request.getParameter("country");
        Locale locale = new Locale(userLang, userCountry);
        
        // Use:
        String userLang = request.getParameter("lang");
        Set<String> supportedLanguages = Set.of("en", "es", "fr", "de");
        if (supportedLanguages.contains(userLang)) {
            Locale locale = new Locale(userLang);
        } else {
            locale = Locale.getDefault();
        }

  - id: java-printf-format-injection
    message: 'Format string vulnerability: printf-style format with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $FORMAT = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: System.out.printf($FORMAT, ...)
              - pattern: $WRITER.printf($FORMAT, ...)
              - pattern: $STREAM.format($FORMAT, ...)
              - pattern: PrintStream.format($FORMAT, ...)
    metadata:
      category: input-validation
      cwe: CWE-134
      solution: |
        Use predefined format strings and validate user input as arguments:
        
        // Instead of:
        String userFormat = request.getParameter("format");
        System.out.printf(userFormat, data);
        
        // Use:
        String userData = request.getParameter("data");
        System.out.printf("User data: %s%n", userData);

  - id: java-messageformat-injection
    message: 'Format injection vulnerability: MessageFormat with user input'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $PATTERN = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: MessageFormat.format($PATTERN, ...)
              - pattern: new MessageFormat($PATTERN).format(...)
    metadata:
      category: input-validation
      cwe: CWE-134
      solution: |
        Use predefined MessageFormat patterns and validate arguments:
        
        // Instead of:
        String userPattern = request.getParameter("pattern");
        String result = MessageFormat.format(userPattern, args);
        
        // Use:
        String userName = request.getParameter("name");
        String result = MessageFormat.format("Hello {0}, welcome back!", userName);

  - id: java-http-parameter-pollution
    message: 'HTTP parameter pollution: Using first value without validation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: String $VAR = $VALUES[0];
    metadata:
      category: input-validation
      cwe: CWE-235
      framework: servlet
      solution: |
        Handle multiple parameter values appropriately:
        
        // Instead of:
        String[] values = request.getParameterValues("action");
        String action = values[0];
        
        // Use:
        String[] values = request.getParameterValues("action");
        if (values == null || values.length == 0) {
            throw new IllegalArgumentException("Action parameter required");
        }
        
        // Check for parameter pollution
        if (values.length > 1) {
            throw new IllegalArgumentException("Multiple action parameters not allowed");
        }
        
        String action = values[0];
        // Validate the single value
        Set<String> allowedActions = Set.of("save", "delete", "update");
        if (!allowedActions.contains(action)) {
            throw new IllegalArgumentException("Invalid action");
        }

  # ===========================================================================
  # 12. SESSION MANAGEMENT
  # ===========================================================================

  - id: java-session-token-url
    message: 'Session management flaw: Session token exposed in URL'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: $RESPONSE.sendRedirect($URL + $VAR)
      - metavariable-regex:
          metavariable: $URL
          regex: '.*sessionId=.*'
    metadata:
      category: session-management
      cwe: CWE-598
      solution: |
        Use secure session management without exposing session IDs in URLs:
        
        // Instead of:
        String sessionId = session.getId();
        response.sendRedirect("/dashboard?sessionId=" + sessionId);
        
        // Use:
        // Let container manage sessions automatically through cookies
        response.sendRedirect("/dashboard");
        
        // Or use POST with hidden form fields for sensitive operations:
        // <form method="POST" action="/secure-action">
        //   <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>
        // </form>

  # ===========================================================================
  # 13. FILE OPERATIONS
  # ===========================================================================

  - id: java-file-upload-unrestricted
    message: 'File upload vulnerability: Unrestricted file upload location'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - patterns:
              - pattern: $FILE.transferTo(new File($PATH + $FILE.getOriginalFilename()))
              - pattern-not-inside: |
                  $METHOD(...) {
                    ...
                    Set<String> $ALLOWED = ...;
                    if (!$ALLOWED.contains($VAR) || ...) {
                      throw ...;
                    }
                    ...
                  }
          - patterns:
              - pattern: $FILE.transferTo(new File($FILE.getOriginalFilename()))
              - pattern-not-inside: |
                  $METHOD(...) {
                    ...
                    Set<String> $ALLOWED = ...;
                    if (!$ALLOWED.contains($VAR) || ...) {
                      throw ...;
                    }
                    ...
                  }
          - patterns:
              - pattern: $PART.write($PATH + $PART.getSubmittedFileName())
              - pattern-not-inside: |
                  $METHOD(...) {
                    ...
                    Set<String> $ALLOWED = ...;
                    if (!$ALLOWED.contains($VAR) || ...) {
                      throw ...;
                    }
                    ...
                  }
    metadata:
      category: file-operations
      cwe: CWE-434
      solution: |
        Validate file type, size, and use secure upload directory:
        
        // Instead of:
        MultipartFile file = request.getFile("upload");
        file.transferTo(new File("/uploads/" + file.getOriginalFilename()));
        
        // Use:
        MultipartFile file = request.getFile("upload");
        String contentType = file.getContentType();
        Set<String> allowedTypes = Set.of("image/jpeg", "image/png", "application/pdf");
        
        if (!allowedTypes.contains(contentType) || file.getSize() > 5_000_000) {
            throw new IllegalArgumentException("Invalid file");
        }
        
        String safeFilename = UUID.randomUUID().toString() + "_" + 
            Paths.get(file.getOriginalFilename()).getFileName().toString();
        file.transferTo(new File("/secure/uploads/" + safeFilename));

  - id: java-zip-entry-size-bomb
    message: 'DoS vulnerability: ZIP entry size used directly for array allocation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          # Direct vulnerable patterns
          - pattern: new byte[(int)$ENTRY.getSize()]
          - pattern: new byte[$ENTRY.getSize()]
          - pattern: new byte[(int) $ENTRY.getSize()]
      - pattern-not-inside: |
          $SIZE = $ENTRY.getSize();
          ...
          if ($SIZE > $LIMIT || $SIZE < 0) {
              ...
          }
    metadata:
      category: file-operations
      cwe: CWE-409
      solution: |
        Validate ZIP entry sizes before creating arrays:
        
        // BAD:
        ZipEntry entry = zipInputStream.getNextEntry();
        byte[] buffer = new byte[(int) entry.getSize()];
        
        // GOOD:
        ZipEntry entry = zipInputStream.getNextEntry();
        long size = entry.getSize();
        long maxSize = 100 * 1024 * 1024; // 100MB limit
        
        if (size > maxSize || size < 0) {
            throw new IllegalArgumentException("Entry too large: " + size);
        }
        
        // Use fixed buffer size for streaming
        byte[] buffer = new byte[8192];
        int totalExtracted = 0;
        int maxTotalSize = 500 * 1024 * 1024;

  - id: java-objectoutputstream-serialization-risk
    message: 'Serialization risk: Sensitive data in ObjectOutputStream'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  ObjectOutputStream $OOS = new ObjectOutputStream(...);
                  ...
              - pattern: $OOS.writeObject($SENSITIVE_OBJECT)
          - pattern: new ObjectOutputStream(...).writeObject($USER_CONTROLLED_OBJECT)
    metadata:
      category: file-operations
      cwe: CWE-502
      solution: |
        Use DTOs without sensitive fields for serialization:
        
        // Instead of:
        User userWithPassword = new User("Alice", "secret123");
        oos.writeObject(userWithPassword);
        
        // Use:
        UserDto safeUser = new UserDto("Alice", null);
        oos.writeObject(safeUser);

  # ===========================================================================
  # 14. NETWORK/COMMUNICATION
  # ===========================================================================

  - id: java-socket-factory-bypass
    message: 'Network security risk: User-controlled socket destination'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $SF.createSocket($HOST, $PORT)
          - pattern: $SF.createSocket($HOST, $PORT, $LOCAL_HOST, $LOCAL_PORT)
      - pattern-inside: |
          $METHOD(...) {
            ...
            SocketFactory $SF = SSLSocketFactory.getDefault();
            ...
          }
      - pattern-not-inside: |
          $METHOD(...) {
            ...
            Set<String> $ALLOWED = ...;
            if (!$ALLOWED.contains($HOST)) {
              throw ...;
            }
            ...
          }
    metadata:
      category: network-communication
      cwe: CWE-918
      solution: |
        Validate destination hosts against allowlists:
        
        // Instead of:
        String userHost = request.getParameter("host");
        SocketFactory sf = SSLSocketFactory.getDefault();
        Socket socket = sf.createSocket(userHost, 443);
        
        // Use:
        String userHost = request.getParameter("host");
        Set<String> allowedHosts = Set.of("api.example.com", "secure.partner.com");
        
        if (!allowedHosts.contains(userHost)) {
            throw new IllegalArgumentException("Invalid host");
        }
        
        SocketFactory sf = SSLSocketFactory.getDefault();
        Socket socket = sf.createSocket(userHost, 443);

  - id: java-server-socket-dos
    message: "DoS vulnerability: User-controlled ServerSocket port"
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          int $PORT = Integer.parseInt(ServletActionContext.getRequest().getParameter(...));
          ...
          new java.net.ServerSocket($PORT);
      # Skip methods that validate port range
      - pattern-not-inside: |
          public $TYPE $METHOD(...) {
            ...
            if ($PORT < $MIN || $PORT > $MAX) {
              ...
            }
            ...
          }
    metadata:
      category: network-communication
      cwe: "CWE-770"
      solution: |
        Validate port ranges before binding ServerSocket:
        
        // UNSAFE:
        int userPort = Integer.parseInt(request.getParameter("port"));
        new ServerSocket(userPort);
        
        // SAFE:
        int requestedPort = Integer.parseInt(request.getParameter("port"));
        if (requestedPort < 8000 || requestedPort > 65535) {
            throw new IllegalArgumentException("Port out of allowed range");
        }
        new ServerSocket(configuredPort); // Use config value, not user input

  - id: java-email-header-injection
    message: 'Email injection: User input in email recipients'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          String $TO = request.getParameter("to");
          ...
          MimeMessage $MSG = new MimeMessage(...);
          ...
      - pattern: $MSG.setRecipients(Message.RecipientType.TO, $TO)
    metadata:
      category: network-communication
      cwe: CWE-150
      solution: |
        Validate email addresses and sanitize headers:
        
        // Instead of:
        String toEmail = request.getParameter("to");
        MimeMessage msg = new MimeMessage(session);
        msg.setRecipients(Message.RecipientType.TO, toEmail);
        
        // Use:
        String toEmail = request.getParameter("to");
        
        // Validate email format
        String emailPattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        if (!toEmail.matches(emailPattern) || toEmail.contains("\n") || toEmail.contains("\r")) {
            throw new IllegalArgumentException("Invalid email address");
        }
        
        MimeMessage msg = new MimeMessage(session);
        msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(toEmail));

  - id: java-email-smtp-injection
    message: 'SMTP injection: Direct InternetAddress.parse() usage in Transport.send()'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Target the specific dangerous pattern - direct parse in send
          - pattern: Transport.send($MSG, InternetAddress.parse($VAR))
          - pattern: $TRANSPORT.sendMessage($MSG, InternetAddress.parse($VAR))
          # Direct with request parameter
          - pattern: Transport.send($MSG, InternetAddress.parse(request.getParameter(...)))
    metadata:
      category: network-communication
      cwe: CWE-150
      solution: |
        Separate parsing from sending and add validation:
        
        // BAD:
        String userAddresses = request.getParameter("recipients");
        Transport.send(message, InternetAddress.parse(userAddresses));
        
        // GOOD:
        String userAddresses = request.getParameter("recipients");
        String emailPattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        String[] addresses = userAddresses.split(",");
        for (String addr : addresses) {
            String cleanAddr = addr.trim();
            if (!cleanAddr.matches(emailPattern) || cleanAddr.contains("\\n")) {
                throw new IllegalArgumentException("Invalid email");
            }
        }
        InternetAddress[] recipients = InternetAddress.parse(userAddresses);
        Transport.send(message, recipients);

  # ===========================================================================
  # 15. BUSINESS LOGIC
  # ===========================================================================

  - id: java-race-condition-payment
    message: 'Race condition: Non-atomic balance check and withdrawal'
    languages:
      - java
    severity: ERROR
    patterns:
    - pattern-either:
        - pattern: |
            if ($ACCOUNT.getBalance() >= $AMOUNT) {
              ...
              $ACCOUNT.withdraw($AMOUNT);
            }
        - pattern: |
            if ($ACCOUNT.getBalance().compareTo($AMOUNT) >= 0) {
              ...
              $ACCOUNT.withdraw($AMOUNT);
            }
    metadata:
      category: business-logic
      cwe: CWE-362
      business_logic: true
      solution: |
        Use atomic operations or proper synchronization for financial transactions:
        
        // Instead of:
        if (account.getBalance() >= amount) {
            account.withdraw(amount);
        }
        
        // Use:
        // Atomic withdrawal method
        boolean success = account.atomicWithdraw(amount);
        if (!success) {
            throw new InsufficientFundsException("Insufficient balance");
        }
        
        // Or use database-level constraints:
        @Transactional(isolation = Isolation.SERIALIZABLE)
        public void withdraw(Long accountId, BigDecimal amount) {
            Account account = accountRepository.findByIdWithLock(accountId);
            if (account.getBalance().compareTo(amount) >= 0) {
                account.setBalance(account.getBalance().subtract(amount));
            }
        }

  - id: java-price-manipulation
    message: "Business logic flaw: User-controlled price parameter"
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Direct user price setting
          - pattern: |
              BigDecimal $PRICE = new BigDecimal(request.getParameter("price"));
              ...
              $ORDER.setPrice($PRICE);
          # Inline user price setting  
          - pattern: |
              $ORDER.setPrice(new BigDecimal(request.getParameter("price")));
          # Variable then set pattern
          - pattern: |
              $PRICE = new BigDecimal(request.getParameter("price"));
              ...
              $ORDER.setPrice($PRICE);
    metadata:
      category: business-logic
      cwe: "CWE-840"
      business_logic: true
      solution: |
        Calculate prices server-side and validate against product catalog:
        
        // Instead of:
        BigDecimal userPrice = new BigDecimal(request.getParameter("price"));
        order.setPrice(userPrice);
        
        // Use:
        String productId = request.getParameter("productId");
        int quantity = Integer.parseInt(request.getParameter("quantity"));
        
        Product product = productService.findById(productId);
        BigDecimal totalPrice = product.getPrice().multiply(BigDecimal.valueOf(quantity));
        order.setPrice(totalPrice);
        order.setProductId(productId);
        order.setQuantity(quantity);

  # ===========================================================================
  # 16. DOS/RESOURCE EXHAUSTION
  # ===========================================================================

  - id: java-process-waitfor-dos
    message: 'DoS vulnerability: Process.waitFor() without timeout'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $PROCESS.waitFor()
          - pattern: Runtime.getRuntime().exec(...).waitFor()
    metadata:
      category: dos-resource-exhaustion
      cwe: CWE-400
      solution: |
        Use waitFor with timeout to prevent indefinite blocking:
        
        // Instead of:
        Process process = Runtime.getRuntime().exec("command");
        int exitCode = process.waitFor();
        
        // Use:
        Process process = Runtime.getRuntime().exec("command");
        boolean finished = process.waitFor(30, TimeUnit.SECONDS);
        if (!finished) {
            process.destroyForcibly();
            throw new TimeoutException("Process timed out");
        }

  - id: java-memory-dos-large-array-corrected
    message: 'DoS vulnerability: User-controlled array size allocation'
    languages:
      - java
    severity: WARNING
    patterns:
      # Only match when array size comes from user input
      - pattern-inside: |
          $SIZE = Integer.parseInt(request.getParameter(...));
          ...
      - pattern-either:
          - pattern: new byte[$SIZE]
          - pattern: new int[$SIZE]
          - pattern: new String[$SIZE]
          - pattern: new Object[$SIZE]
      # Exclude cases where validation exists
      - pattern-not-inside: |
          if ($SIZE <= 0 || $SIZE > $LIMIT) {
            throw ...;
          }
    metadata:
      category: dos-resource-exhaustion
      cwe: CWE-770
      solution: |
        Validate array size limits before allocation:
        
        // Instead of:
        int userSize = Integer.parseInt(request.getParameter("size"));
        byte[] array = new byte[userSize];
        
        // Use:
        int userSize = Integer.parseInt(request.getParameter("size"));
        int maxSize = 1024 * 1024; // 1MB limit
        
        if (userSize <= 0 || userSize > maxSize) {
            throw new IllegalArgumentException("Invalid array size");
        }
        
        byte[] array = new byte[userSize];

  - id: java-recursive-dos
    message: 'DoS vulnerability: Potential stack overflow from uncontrolled recursion'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          public $TYPE $METHOD($PARAM_TYPE $DEPTH) {
            ...
          }
      - pattern: $METHOD($DEPTH + 1)
      - pattern-not-inside: |
          public $TYPE $METHOD($PARAM_TYPE $DEPTH) {
            ...
            if ($DEPTH > $LIMIT) {
              throw ...;
            }
            ...
          }
      - pattern-not-inside: |
          public $TYPE $METHOD($PARAM_TYPE $DEPTH) {
            ...
            if ($DEPTH >= $LIMIT) {
              throw ...;
            }
            ...
          }
    metadata:
      category: dos-resource-exhaustion
      cwe: CWE-674
      solution: |
        Add recursion depth limits to prevent stack overflow:
        
        // Instead of:
        public void processData(int depth) {
            if (someCondition) {
                processData(depth + 1);
            }
        }
        
        // Use:
        private static final int MAX_RECURSION_DEPTH = 100;
        
        public void processData(int depth) {
            if (depth > MAX_RECURSION_DEPTH) {
                throw new IllegalStateException("Maximum recursion depth exceeded");
            }
            if (someCondition) {
                processData(depth + 1);
            }
        }

  # ===========================================================================
  # 17. LOGGING
  # ===========================================================================

  - id: java-taint-header-to-log
    message: 'Taint flow: HTTP header reaches logging (log injection risk)'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          # Pattern for method parameter (matches your code)
          - patterns:
              - pattern-inside: |
                  $RETURN_TYPE $METHOD(..., HttpServletRequest $REQUEST, ...) {
                    ...
                  }
              - pattern-inside: |
                  String $HEADER = $REQUEST.getHeader(...);
                  ...
              - pattern-either:
                  - pattern: $LOGGER.info($STR + $HEADER)
                  - pattern: $LOGGER.info($HEADER + $STR)
                  - pattern: $LOGGER.info($HEADER)
          # Pattern for variable assignment
          - patterns:
              - pattern-inside: |
                  String $HEADER = $REQUEST.getHeader(...);
                  ...
              - pattern-either:
                  - pattern: $LOGGER.info($STR + $HEADER)
                  - pattern: $LOGGER.info($HEADER + $STR)
                  - pattern: $LOGGER.info($HEADER)
    metadata:
      category: logging
      cwe: CWE-117
      taint_flow: true
      solution: |
        Sanitize or validate header values before logging to prevent log injection:
        
        // Instead of:
        String userAgent = request.getHeader("User-Agent");
        logger.info("Request from: " + userAgent);
        
        // Use:
        String userAgent = request.getHeader("User-Agent");
        String sanitizedAgent = userAgent.replaceAll("[\r\n\t]", "_");
        logger.info("Request from: {}", sanitizedAgent);

  - id: java-log4j-jndi-injection
    message: 'RCE vulnerability: Log4j JNDI injection (CVE-2021-44228)'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_INPUT = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: $LOGGER.info($USER_INPUT + ...)
              - pattern: $LOGGER.error($USER_INPUT + ...)
              - pattern: $LOGGER.warn($USER_INPUT + ...)
              - pattern: $LOGGER.debug($USER_INPUT + ...)
              - pattern: $LOGGER.info($STR + $USER_INPUT)
              - pattern: $LOGGER.error($STR + $USER_INPUT)
    metadata:
      category: logging
      cwe: CWE-74
      library: log4j
      cve: CVE-2021-44228
      solution: |
        Update Log4j to version 2.17.0+ and sanitize user input in logs:
        
        // Instead of:
        String userInput = request.getParameter("data");
        logger.info("User data: " + userInput);
        
        // Use:
        String userInput = request.getParameter("data");
        // Update log4j to 2.17.0+ and sanitize input
        String sanitizedInput = userInput.replaceAll("[${}]", "_");
        logger.info("User data: {}", sanitizedInput);
        
        // Also set system property: -Dlog4j2.formatMsgNoLookups=true

  - id: java-log4j-message-lookup
    message: 'RCE vulnerability: Log4j message lookup injection'
    languages:
      - java
    severity: ERROR
    patterns:
      - patterns:
          - pattern-inside: |
              String $USER_INPUT = $REQUEST.getParameter(...);
              ...
          - pattern-either:
              - pattern: $LOGGER.info("${jndi:" + $USER_INPUT + "}")
              - pattern: $LOGGER.error("${" + $USER_INPUT + "}")
              - pattern: $LOGGER.info("$${" + $USER_INPUT + "}")
    metadata:
      category: logging
      cwe: CWE-74
      library: log4j
      cve: CVE-2021-44228
      solution: |
        Never construct log messages with user-controlled lookup patterns:
        
        // Instead of:
        String userLookup = request.getParameter("lookup");
        logger.info("${jndi:" + userLookup + "}");
        
        // Use:
        String userData = request.getParameter("data");
        logger.info("User provided: {}", userData);
        
        // Ensure log4j 2.17.0+ and disable lookups: -Dlog4j2.formatMsgNoLookups=true

  # ===========================================================================
  # 18. FRAMEWORK-SPECIFIC SECURITY
  # ===========================================================================

  - id: java-spring-cache-poisoning
    message: 'Cache poisoning vulnerability: User-controlled cache key'
    languages: [java]
    severity: WARNING
    patterns:
      - pattern: |
          @Cacheable(key = $KEY)
          $RETURN_TYPE $METHOD(...) { ... }
      - pattern-not: |
          @Cacheable(key = "'" + $PREFIX + "'" + " + " + "#$PARAM")
          $RETURN_TYPE $METHOD(...) { ... }
      - pattern-not: |
          @Cacheable(key = $KEY)
          $RETURN_TYPE $METHOD(@Pattern(...) $TYPE $PARAM) { ... }
      - pattern-not: |
          @Cacheable(key = $KEY)
          $RETURN_TYPE $METHOD(..., @Pattern(...) $TYPE $PARAM, ...) { ... }
    metadata:
      category: framework-specific
      cwe: CWE-20
      framework: spring
      solution: |
        Use safe cache key generation and validate parameters:
        
        // Instead of:
        @Cacheable(key = "#userId")
        public User getUser(String userId) { ... }
        
        // Use:
        @Cacheable(key = "'user_' + #userId")
        public User getUser(@Valid @Pattern(regexp = "\\d+") String userId) { ... }

  - id: java-jaxrs-missing-security-headers
    message: "Security headers missing: JAX-RS response without security headers"
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @Path(...)
          class $CLASS {
            ...
          }
      - pattern-either:
          - pattern: |
              @GET
              @Path(...)
              public Response $METHOD(...) {
                ...
                return Response.ok($DATA).build();
              }
    metadata:
      category: framework-specific
      cwe: "CWE-693"
      framework: jaxrs
      solution: |
        Add security headers to JAX-RS responses:
        
        // Instead of:
        @GET
        public Response getData() {
            return Response.ok(data).build();
        }
        
        // Use:
        @GET
        public Response getData() {
            return Response.ok(data)
                .header("X-Content-Type-Options", "nosniff")
                .header("X-Frame-Options", "DENY")
                .header("X-XSS-Protection", "1; mode=block")
                .header("Content-Security-Policy", "default-src 'self'")
                .build();
        }

  - id: java-cors-credentials-wildcard
    message: 'CORS security flaw: Wildcard origin with credentials allowed'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          $RESPONSE.setHeader("Access-Control-Allow-Origin", "*");
          ...
      - pattern: $RESPONSE.setHeader("Access-Control-Allow-Credentials", "true")
    metadata:
      category: framework-specific
      cwe: CWE-942
      solution: |
        Use specific origins instead of wildcard when credentials are allowed:
        
        // Instead of:
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Credentials", "true");
        
        // Use:
        String origin = request.getHeader("Origin");
        Set<String> allowedOrigins = Set.of("https://app.example.com", "https://admin.example.com");
        
        if (allowedOrigins.contains(origin)) {
            response.setHeader("Access-Control-Allow-Origin", origin);
            response.setHeader("Access-Control-Allow-Credentials", "true");
        }

  - id: java-spring-redirect-view
    message: 'Open redirect vulnerability: Unvalidated RedirectView URL'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $URL = request.getParameter(...);
              ...
              return new RedirectView($URL);
          - pattern: new RedirectView($USER_INPUT + ...)
    metadata:
      category: framework-specific
      cwe: CWE-601
      framework: spring
      solution: |
        Validate redirect URLs against allowlists:
        
        // Instead of:
        String redirectUrl = request.getParameter("redirect");
        return new RedirectView(redirectUrl);
        
        // Use:
        String redirectParam = request.getParameter("redirect");
        Map<String, String> allowedRedirects = Map.of(
            "home", "/dashboard",
            "profile", "/user/profile",
            "logout", "/auth/logout"
        );
        
        String url = allowedRedirects.get(redirectParam);
        if (url == null) {
            url = "/dashboard"; // Default safe redirect
        }
        
        return new RedirectView(url);

  - id: java-spring-boot-sensitive-config
    message: 'Configuration exposure: Sensitive data in configuration properties'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              @ConfigurationProperties(...)
              public class $CLASS {
                private String password;
                ...
              }
          - pattern: |
              @Value("${database.password}")
              private String $FIELD;
    metadata:
      category: framework-specific
      cwe: CWE-200
      framework: spring-boot
      solution: |
        Use environment variables and secure configuration management:
        
        // Instead of:
        @Value("${database.password}")
        private String dbPassword;
        
        // Use:
        @Value("${DATABASE_PASSWORD:#{null}}")
        private String dbPassword;
        
        // Set environment variable: DATABASE_PASSWORD=actual_password
        
        // Or use Spring Cloud Config with encryption:
        // In application.yml: password: '{cipher}encrypted_value'
        // Use @ConfigurationProperties with validation:
        @ConfigurationProperties("database")
        @Validated
        public class DatabaseConfig {
            @NotNull private String password;
        }

  # ===========================================================================
  # 19. REFLECTION/CLASS LOADING
  # ===========================================================================

  - id: java-classloader-injection
    message: "Class loading vulnerability: User input in ClassLoader.loadClass()"
    languages:
      - java
    severity: ERROR
    patterns:
      # Match only direct consecutive usage (no validation in between)
      - pattern: |
          String $VAR = ServletActionContext.getRequest().getParameter(...);
          Class<?> $CLASS = ClassLoader.getSystemClassLoader().loadClass($VAR);
    metadata:
      category: reflection-class-loading
      cwe: "CWE-470"
      solution: |
        Validate class names against allowlists before loading:
        
        String userClass = request.getParameter("class");
        Set<String> allowedClasses = Set.of("com.example.SafeClass1");
        
        if (allowedClasses.contains(userClass)) {
            Class<?> clazz = ClassLoader.getSystemClassLoader().loadClass(userClass);
        } else {
            throw new IllegalArgumentException("Class not allowed");
        }

  - id: java-reflection-field-access-bypass
    message: 'Security bypass: Reflection field access control override'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $CLASS.getDeclaredField($USER_INPUT + ...)
          - pattern: $FIELD.setAccessible(true)
    metadata:
      category: reflection-class-loading
      cwe: CWE-470
      solution: |
        Avoid reflection with user input or validate field names:
        
        // Instead of:
        String fieldName = request.getParameter("field");
        Field field = MyClass.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        
        // Use:
        String fieldName = request.getParameter("field");
        Set<String> allowedFields = Set.of("name", "email", "status");
        
        if (!allowedFields.contains(fieldName)) {
            throw new IllegalArgumentException("Field access not allowed");
        }
        
        // Use getter methods instead of reflection when possible
        switch (fieldName) {
            case "name": return object.getName();
            case "email": return object.getEmail();
            default: throw new IllegalArgumentException("Unknown field");
        }

  # ===========================================================================
  # 20. REMOTE CODE EXECUTION
  # ===========================================================================

  - id: java-jndi-remote-codebase
    message: 'RCE vulnerability: JNDI lookup with remote codebase'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Match the actual vulnerable line directly
          - pattern: $CONTEXT.lookup("rmi://" + $VAR)
          - pattern: $CONTEXT.lookup("ldap://" + $VAR)  
          - pattern: $CONTEXT.lookup("ldaps://" + $VAR)
          - pattern: $CONTEXT.lookup("dns://" + $VAR)
          - pattern: $CONTEXT.lookup("iiop://" + $VAR)
          # With parentheses variations
          - pattern: $CONTEXT.lookup(("rmi://" + $VAR))
          - pattern: $CONTEXT.lookup(("ldap://" + $VAR))
    metadata:
      category: remote-code-execution
      cwe: CWE-74
      solution: |
        Disable remote class loading and validate JNDI names:
        
        // Instead of:
        String userLookup = request.getParameter("service");
        Object obj = context.lookup("rmi://" + userLookup);
        
        // Use:
        // Set system properties to disable remote class loading:
        System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase", "false");
        System.setProperty("com.sun.jndi.cosnaming.object.trustURLCodebase", "false");
        
        // Use local JNDI names only:
        String serviceName = request.getParameter("service");
        Set<String> allowedServices = Set.of("java:comp/env/jdbc/myDB", "java:comp/env/jms/queue");
        
        if (allowedServices.contains(serviceName)) {
            Object obj = context.lookup(serviceName);
        }

  - id: java-scriptengine-url-eval
    message: 'RCE vulnerability: ScriptEngine evaluating URL content'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          # Direct pattern - target the exact vulnerable line
          - pattern: $ENGINE.eval(new java.net.URL($VAR).openStream())
          - pattern: $ENGINE.eval(new URL($VAR).openStream())
          # Variations with different syntax
          - pattern: engine.eval(new java.net.URL($VAR).openStream())
          - pattern: engine.eval(new URL($VAR).openStream())
    metadata:
      category: remote-code-execution
      cwe: CWE-94
      solution: |
        Use local script files with allowlist validation:
        
        // BAD:
        String remoteScript = request.getParameter("script");
        engine.eval(new java.net.URL(remoteScript).openStream());
        
        // GOOD:
        String scriptName = request.getParameter("script");
        Set<String> allowedScripts = Set.of("validation.js", "calculation.js");
        if (!allowedScripts.contains(scriptName)) {
            throw new IllegalArgumentException("Script not allowed");
        }
        try (FileReader reader = new FileReader("/secure/scripts/" + scriptName)) {
            engine.eval(reader);
        }

  # ===========================================================================
  # 21. CONCURRENCY
  # ===========================================================================

  - id: java-thread-stop-unsafe-v2
    message: 'Concurrency flaw: Thread.stop() is unsafe and deprecated'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: $THREAD.stop()
    metadata:
      category: concurrency
      cwe: CWE-662
      solution: |
        Use interrupt() and proper thread coordination instead of stop():
        
        // Instead of:
        thread.stop();
        
        // Use:
        thread.interrupt();
        
        // In thread implementation:
        public void run() {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    // Do work
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        // Or use volatile flags for coordination:
        private volatile boolean running = true;
        
        public void shutdown() {
            running = false;
        }

  - id: java-unsafe-singleton
    message: 'Concurrency issue: Unsafe singleton pattern (not thread-safe)'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          public class $CLASS {
            private static $CLASS instance;
            ...
            public static $CLASS getInstance() {
              ...
            }
          }
      - pattern: |
          if (instance == null) {
            instance = new $CLASS();
          }
      - pattern-not-inside: |
          synchronized (...) {
            ...
          }
    metadata:
      category: concurrency
      cwe: CWE-362
      solution: |
        Use thread-safe singleton implementation:
        
        // Instead of:
        public class UnsafeSingleton {
            private static UnsafeSingleton instance;
            
            public static UnsafeSingleton getInstance() {
                if (instance == null) {
                    instance = new UnsafeSingleton();
                }
                return instance;
            }
        }
        
        // Use:
        public class SafeSingleton {
            private static final SafeSingleton INSTANCE = new SafeSingleton();
            
            private SafeSingleton() {}
            
            public static SafeSingleton getInstance() {
                return INSTANCE;
            }
        }

  - id: java-shared-mutable-state
    message: 'Concurrency issue: Shared mutable static collection'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: public static List<$T> $FIELD = new ArrayList<>();
          - pattern: public static Map<$K, $V> $FIELD = new HashMap<>();
          - pattern: public static Set<$T> $FIELD = new HashSet<>();
    metadata:
      category: concurrency
      cwe: CWE-362
      solution: |
        Use immutable collections or proper synchronization:
        
        // Instead of:
        public static List<String> sharedList = new ArrayList<>();
        public static Map<String, String> sharedMap = new HashMap<>();
        
        // Use:
        public static final List<String> IMMUTABLE_LIST = List.of("value1", "value2");
        public static final Map<String, String> IMMUTABLE_MAP = Map.of("key1", "value1");
        
        // Or use concurrent collections:
        public static final ConcurrentHashMap<String, String> THREAD_SAFE_MAP = 
            new ConcurrentHashMap<>();

  - id: java-race-condition-static-field
    message: 'Concurrency issue: Unsynchronized access to static field'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          public class $CLASS {
            static $TYPE $FIELD;
            ...
            public $RETURN_TYPE $METHOD(...) {
              ...
            }
          }
      - pattern: $FIELD = $FIELD + $VALUE
      - pattern-not-inside: |
          synchronized (...) {
            ...
          }
    metadata:
      category: concurrency
      cwe: CWE-362
      solution: |
        Use proper synchronization or concurrent collections for static fields:
        
        // Instead of:
        public class Counter {
            static int count;
            
            public void increment() {
                count = count + 1; // Race condition
            }
        }
        
        // Use:
        public class Counter {
            private static final AtomicInteger count = new AtomicInteger(0);
            
            public void increment() {
                count.incrementAndGet();
            }
        }

  - id: java-double-checked-locking
    message: 'Concurrency issue: Double-checked locking pattern may be unsafe'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          public class $CLASS {
            private static $CLASS instance;
            ...
          }
      - pattern: |
          if (instance == null) {
            synchronized (...) {
              if (instance == null) {
                instance = new $TYPE(...);
              }
            }
          }
      - pattern-not-inside: |
          private static volatile $TYPE instance;
          ...
    metadata:
      category: concurrency
      cwe: CWE-609
      solution: |
        Use volatile keyword or initialization-on-demand holder pattern:
        
        // Instead of:
        private static Singleton instance;
        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
        
        // Use:
        private static volatile Singleton instance;
        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }

  # ===========================================================================
  # 22. MEMORY SAFETY
  # ===========================================================================

  - id: java-unsafe-memory-access
    message: 'Memory safety risk: sun.misc.Unsafe usage'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: Unsafe.getUnsafe()
          - pattern: $UNSAFE.allocateMemory(...)
          - pattern: $UNSAFE.putAddress(...)
          - pattern: $UNSAFE.getAddress(...)
    metadata:
      category: memory-safety
      cwe: CWE-119
      solution: |
        Avoid sun.misc.Unsafe and use safe Java alternatives:
        
        // Instead of:
        Unsafe unsafe = Unsafe.getUnsafe();
        long memory = unsafe.allocateMemory(1024);
        
        // Use:
        // Use standard Java collections and NIO for memory management
        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
        
        // Or use memory-mapped files:
        try (RandomAccessFile file = new RandomAccessFile("data.bin", "rw");
             FileChannel channel = file.getChannel()) {
            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
        }

  # ===========================================================================
  # 23. SUPPLY CHAIN
  # ===========================================================================

  - id: java-dangerous-fastjson
    message: 'Supply chain risk: Fastjson usage vulnerable to deserialization attacks'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: JSON.parseObject($USER_INPUT)
          - pattern: JSON.parse($USER_INPUT)
    metadata:
      category: supply-chain
      cwe: CWE-502
      library: fastjson
      solution: |
        Replace Fastjson with safer JSON libraries like Jackson or Gson:
        
        // Instead of:
        String userJson = request.getBody();
        Object obj = JSON.parseObject(userJson);
        
        // Use Jackson:
        ObjectMapper mapper = new ObjectMapper();
        MyClass obj = mapper.readValue(userJson, MyClass.class);
        
        // Or use Gson:
        Gson gson = new Gson();
        MyClass obj = gson.fromJson(userJson, MyClass.class);
        
        // If you must use Fastjson, disable autoType:
        // ParserConfig.getGlobalInstance().setSafeMode(true);

  - id: java-android-intent-data-leak
    message: 'Android security risk: Sensitive data in Intent extras'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $INTENT.putExtra("password", $DATA)
          - pattern: $INTENT.putExtra("secret", $DATA)
          - pattern: $INTENT.putExtra("creditCard", $DATA)
          - pattern: $INTENT.putExtra("token", $DATA)
          - pattern: $INTENT.putExtra("apiKey", $DATA)
    metadata:
      category: supply-chain
      cwe: CWE-200
      platform: android
      solution: |
        Avoid putting sensitive data in Intent extras:
        
        // Instead of:
        Intent intent = new Intent(this, NextActivity.class);
        intent.putExtra("password", userPassword);
        intent.putExtra("creditCard", cardNumber);
        
        // Use:
        Intent intent = new Intent(this, NextActivity.class);
        intent.putExtra("userId", userId); // Non-sensitive identifier only
        
        // Store sensitive data in secure storage:
        SharedPreferences securePrefs = getSharedPreferences("secure", MODE_PRIVATE);
        securePrefs.edit().putString("temp_data", encryptedData).apply();

  - id: java-android-webview-javascript
    message: 'Android security risk: JavaScript enabled in WebView'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: $WEBVIEW.getSettings().setJavaScriptEnabled(true)
      - pattern-not-inside: |
          if ($CONDITION) {
            ...
          }
    metadata:
      category: supply-chain
      cwe: CWE-79
      platform: android
      solution: |
        Only enable JavaScript when necessary and implement proper security:
        
        // Instead of:
        webView.getSettings().setJavaScriptEnabled(true);
        
        // Use:
        // Only enable if absolutely necessary
        if (requiresJavaScript) {
            webView.getSettings().setJavaScriptEnabled(true);
            
            // Add security measures:
            webView.getSettings().setAllowFileAccess(false);
            webView.getSettings().setAllowContentAccess(false);
            webView.getSettings().setAllowFileAccessFromFileURLs(false);
            webView.getSettings().setAllowUniversalAccessFromFileURLs(false);
        }

  - id: java-android-intent-injection
    message: 'Android security risk: Intent injection vulnerability'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          Intent $INTENT = new Intent($ACTION);
          ...
      - pattern: startActivity($INTENT)
      - pattern-not-inside: |
          Set<String> $ALLOWED = ...;
          if (!$ALLOWED.contains($ACTION)) {
            ...
          }
          ...
    metadata:
      category: supply-chain
      cwe: CWE-926
      platform: android
      solution: |
        Validate Intent data and use explicit Intents when possible:
        
        // Instead of:
        Intent intent = getIntent();
        String action = intent.getStringExtra("action");
        Intent newIntent = new Intent(action);
        startActivity(newIntent);
        
        // Use:
        Intent intent = getIntent();
        String action = intent.getStringExtra("action");
        
        Set<String> allowedActions = Set.of("com.example.VIEW", "com.example.EDIT");
        if (!allowedActions.contains(action)) {
            throw new IllegalArgumentException("Invalid action");
        }
        
        // Use explicit Intent with component name
        Intent newIntent = new Intent(this, TargetActivity.class);
        newIntent.setAction(action);
        startActivity(newIntent);

  # ===========================================================================
  # 24. XSS (CROSS-SITE SCRIPTING) - EXTENDED
  # ===========================================================================

  - id: java-xss-servlet-response
    message: 'XSS vulnerability: Unescaped user input in HTTP response'
    languages: [java]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $RESPONSE.getWriter().write("..." + $REQUEST.getParameter(...) + "...");
          - pattern: $RESPONSE.getWriter().write("..." + $REQUEST.getParameter(...));
          - pattern: $RESPONSE.getWriter().write($REQUEST.getParameter(...) + "...");
          - pattern: $RESPONSE.getWriter().println("..." + $REQUEST.getParameter(...) + "...");
          - pattern: $RESPONSE.getWriter().println("..." + $REQUEST.getParameter(...));
          - pattern: $RESPONSE.getWriter().println($REQUEST.getParameter(...) + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $RESPONSE.getWriter().write("..." + $VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $RESPONSE.getWriter().write("..." + $VAR);
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $RESPONSE.getWriter().write($VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $RESPONSE.getWriter().println("..." + $VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $RESPONSE.getWriter().println("..." + $VAR);
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $RESPONSE.getWriter().println($VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUTPUT = "..." + $VAR + "...";
              ...
              $RESPONSE.getOutputStream().write($OUTPUT.getBytes());
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUTPUT = "..." + $VAR;
              ...
              $RESPONSE.getOutputStream().write($OUTPUT.getBytes());
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUTPUT = $VAR + "...";
              ...
              $RESPONSE.getOutputStream().write($OUTPUT.getBytes());
    metadata:
      category: xss
      cwe: CWE-79
      owasp: A03:2021
      solution: |
        Escape user input before outputting to prevent XSS attacks:
        
        // Instead of:
        String userInput = request.getParameter("message");
        response.getWriter().write("Hello " + userInput);
        
        // Use:
        String userInput = request.getParameter("message");
        String escapedInput = HtmlUtils.htmlEscape(userInput);
        response.getWriter().write("Hello " + escapedInput);
        
        // Or validate and sanitize:
        String userInput = request.getParameter("message");
        if (isValidInput(userInput)) {
            String sanitizedInput = sanitizeInput(userInput);
            response.getWriter().write("Hello " + sanitizedInput);
        }

  - id: java-xss-jsp-expression
    message: 'XSS vulnerability: Unescaped JSP expression'
    languages: [java]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $OUT.print("..." + $REQUEST.getParameter(...) + "...");
          - pattern: $OUT.print("..." + $REQUEST.getParameter(...));
          - pattern: $OUT.print($REQUEST.getParameter(...) + "...");
          - pattern: $OUT.println("..." + $REQUEST.getParameter(...) + "...");
          - pattern: $OUT.println("..." + $REQUEST.getParameter(...));
          - pattern: $OUT.println($REQUEST.getParameter(...) + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUT.print("..." + $VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUT.print("..." + $VAR);
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUT.print($VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUT.println("..." + $VAR + "...");
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUT.println("..." + $VAR);
          - pattern: |
              $VAR = $REQUEST.getParameter(...);
              ...
              $OUT.println($VAR + "...");
    metadata:
      category: xss
      cwe: CWE-79
      owasp: A03:2021
      solution: |
        Escape user input before JSP output to prevent XSS attacks:
        
        // Instead of:
        String userInput = request.getParameter("name");
        out.print("Hello " + userInput);
        
        // Use:
        String userInput = request.getParameter("name");
        String escapedInput = HtmlUtils.htmlEscape(userInput);
        out.print("Hello " + escapedInput);
        
        // Or in JSP pages, use JSTL c:out tag:
        // <c:out value="${param.name}" escapeXml="true" />
        
        // For JSP scriptlets:
        String userInput = request.getParameter("comment");
        out.println("Comment: " + StringEscapeUtils.escapeHtml4(userInput));

  - id: java-unsafe-cookie-creation
    message: 'Cookie security flaw: Missing HttpOnly, Secure, or Path attributes'
    languages: [java]
    severity: WARNING
    patterns:
      - pattern: Cookie $COOKIE = new Cookie($NAME, $VALUE);
      - pattern-not-inside: |
          Cookie $COOKIE = new Cookie($NAME, $VALUE);
          ...
          $COOKIE.setHttpOnly(true);
          ...
      - pattern-not-inside: |
          Cookie $COOKIE = new Cookie($NAME, $VALUE);
          ...
          $COOKIE.setSecure(true);
          ...
      - pattern-not-inside: |
          Cookie $COOKIE = new Cookie($NAME, $VALUE);
          ...
          $COOKIE.setPath(...);
          ...
    metadata:
      category: xss
      cwe: CWE-614
      solution: |
        Add security attributes to Cookie to prevent security vulnerabilities:
        
        // Instead of:
        Cookie cookie = new Cookie("sessionId", "abc123");
        response.addCookie(cookie);
        
        // Use:
        Cookie cookie = new Cookie("sessionId", "abc123");
        cookie.setHttpOnly(true);    // Prevent XSS access
        cookie.setSecure(true);      // Only send over HTTPS
        cookie.setPath("/");         // Limit cookie scope
        cookie.setMaxAge(3600);      // Set expiration time
        response.addCookie(cookie);

  - id: java-session-fixation
    message: 'Session fixation vulnerability: Session not regenerated after login'
    languages: [java]
    severity: WARNING
    patterns:
      - pattern: HttpSession $SESSION = $REQUEST.getSession();
      - pattern-not-inside: |
          ...
          $OLDSESSION.invalidate();
          ...
          HttpSession $SESSION = $REQUEST.getSession();
          ...
      - pattern-not-inside: |
          HttpSession $OLDSESSION = $REQUEST.getSession(false);
          ...
          $OLDSESSION.invalidate();
          ...
    metadata:
      category: session-management
      cwe: CWE-384
      solution: |
        Regenerate session ID after authentication to prevent session fixation:
        
        // Instead of:
        HttpSession session = request.getSession();
        session.setAttribute("userId", "12345");
        
        // Use:
        HttpSession oldSession = request.getSession(false);
        if (oldSession != null) {
            oldSession.invalidate();
        }
        HttpSession newSession = request.getSession(true);
        newSession.setAttribute("userId", "12345");

  - id: java-cors-servlet-filter-wildcard
    message: 'CORS misconfiguration: Wildcard origin in servlet filter'
    languages: [java]
    severity: WARNING
    patterns:
      - pattern-inside: |
          public class $CLASS implements Filter {
            ...
          }
      - pattern: $RESPONSE.setHeader("Access-Control-Allow-Origin", "*");
    metadata:
      category: cors
      cwe: CWE-942
      solution: |
        Use specific allowed origins instead of wildcard to prevent CORS attacks:
        
        // Instead of:
        response.setHeader("Access-Control-Allow-Origin", "*");
        
        // Use:
        String origin = request.getHeader("Origin");
        String[] allowedOrigins = {"https://example.com", "https://api.example.com"};
        if (isAllowedOrigin(origin, allowedOrigins)) {
            response.setHeader("Access-Control-Allow-Origin", origin);
        }

  - id: java-missing-csrf-token
    message: 'CSRF vulnerability: POST endpoint without CSRF protection'
    languages: [java]
    severity: WARNING
    patterns:
      - pattern: |
          @RequestMapping(method = RequestMethod.POST, ...)
          public $TYPE $METHOD(...) {
            ...
          }
      - pattern-not-inside: |
          @RequestMapping(method = RequestMethod.POST, ...)
          public $TYPE $METHOD(..., CsrfToken $TOKEN, ...) {
            ...
          }
    metadata:
      category: csrf
      cwe: CWE-352
      framework: spring
      solution: |
        Add CSRF token validation to POST endpoints to prevent CSRF attacks:
        
        // Instead of:
        @RequestMapping(method = RequestMethod.POST, value = "/transfer")
        public String transfer(@RequestParam String amount) {
            // Process transfer without CSRF protection
            return "success";
        }
        
        // Use:
        @RequestMapping(method = RequestMethod.POST, value = "/transfer")
        public String transfer(@RequestParam String amount, 
                             CsrfToken csrfToken,
                             HttpServletRequest request) {
            String providedToken = request.getParameter("_csrf");
            if (csrfToken == null || !csrfToken.getToken().equals(providedToken)) {
                throw new SecurityException("Invalid CSRF token");
            }
            // Process transfer with CSRF protection
            return "success";
        }

  - id: java-unvalidated-redirect
    message: 'Open redirect vulnerability: Unvalidated redirect URL'
    languages: [java]
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $URL = $REQUEST.getParameter(...);
              $RESPONSE.sendRedirect($URL);
          - pattern: return "redirect:" + $REQUEST.getParameter(...);
    metadata:
      category: open-redirect
      cwe: CWE-601
      solution: |
        Validate redirect URLs against allowlist to prevent open redirect attacks:
        
        // Instead of:
        String url = request.getParameter("redirectUrl");
        response.sendRedirect(url);
        // Or:
        return "redirect:" + request.getParameter("next");
        
        // Use:
        String url = request.getParameter("redirectUrl");
        if (isValidRedirectUrl(url)) {
            response.sendRedirect(url);
        } else {
            response.sendRedirect("/default-page");
        }
        
        private boolean isValidRedirectUrl(String url) {
            if (url == null) return false;
            Pattern allowedPattern = Pattern.compile("^(/[^/].*|https://example\\.com/.*)$");
            return allowedPattern.matcher(url).matches();
        }

  - id: java-spring-open-redirect
    message: 'Open redirect vulnerability: Unvalidated redirect parameter'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              @RequestMapping(...)
              public String $METHOD(..., @RequestParam String $REDIRECT, ...) {
                ...
                return "redirect:" + $REDIRECT;
              }
          - pattern: |
              @RequestMapping(...)
              public ModelAndView $METHOD(..., @RequestParam String $REDIRECT, ...) {
                ...
                return new ModelAndView("redirect:" + $REDIRECT);
              }
      # Exclude methods with allowlist validation
      - pattern-not-inside: |
          @RequestMapping(...)
          public String $METHOD(..., @RequestParam String $REDIRECT, ...) {
            ...
            if ($REDIRECT != null && $ALLOWLIST.contains($REDIRECT)) {
              ...
            }
            ...
            return "redirect:" + $SAFE_REDIRECT;
          }
      - pattern-not-inside: |
          @RequestMapping(...)
          public ModelAndView $METHOD(..., @RequestParam String $REDIRECT, ...) {
            ...
            if ($REDIRECT != null && $ALLOWLIST.contains($REDIRECT)) {
              ...
            }
            ...
            return new ModelAndView("redirect:" + $SAFE_REDIRECT);
          }
      # Exclude methods with validation function calls
      - pattern-not-inside: |
          @RequestMapping(...)
          public String $METHOD(..., @RequestParam String $REDIRECT, ...) {
            ...
            if ($REDIRECT != null && $VALIDATION_METHOD($REDIRECT)) {
              ...
            }
            ...
            return "redirect:" + $SAFE_REDIRECT;
          }
      - pattern-not-inside: |
          @RequestMapping(...)
          public ModelAndView $METHOD(..., @RequestParam String $REDIRECT, ...) {
            ...
            if ($REDIRECT != null && $VALIDATION_METHOD($REDIRECT)) {
              ...
            }
            ...
            return new ModelAndView("redirect:" + $SAFE_REDIRECT);
          }
      # Exclude methods that use a different variable for redirect (after validation)
      - pattern-not-inside: |
          @RequestMapping(...)
          public String $METHOD(..., @RequestParam String $REDIRECT, ...) {
            ...
            String $SAFE_VAR = ...;
            ...
            return "redirect:" + $SAFE_VAR;
          }
      - pattern-not-inside: |
          @RequestMapping(...)
          public ModelAndView $METHOD(..., @RequestParam String $REDIRECT, ...) {
            ...
            String $SAFE_VAR = ...;
            ...
            return new ModelAndView("redirect:" + $SAFE_VAR);
          }
    metadata:
      category: open-redirect
      cwe: CWE-601
      framework: spring
      solution: |
        Validate redirect URLs against allowlists:
        
        // Instead of:
        @RequestMapping("/login")
        public String login(@RequestParam String redirect) {
            return "redirect:" + redirect;
        }
        
        // Use:
        @RequestMapping("/login")
        public String login(@RequestParam(required = false) String redirect) {
            Set<String> allowedRedirects = Set.of("/dashboard", "/profile", "/settings");
            
            String safeRedirect = "/dashboard"; // Default
            if (redirect != null && allowedRedirects.contains(redirect)) {
                safeRedirect = redirect;
            }
            
            return "redirect:" + safeRedirect;
        }

  - id: java-spring-csrf-disabled
    message: 'Security risk: CSRF protection disabled in Spring Security'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @EnableWebSecurity
          public class $CLASS extends WebSecurityConfigurerAdapter {
            ...
          }
      - pattern: http.csrf().disable()
    metadata:
      category: csrf
      cwe: CWE-352
      framework: spring
      owasp: A01:2021
      solution: |
        Enable CSRF protection or use proper alternatives for APIs:
        
        // Instead of:
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf().disable();
        }
        
        // Use:
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .ignoringAntMatchers("/api/**"); // Only for stateless APIs
        }
        
        // For REST APIs, use proper authentication:
        // - JWT tokens with proper validation
        // - SameSite cookies
        // - Custom request headers validation

  - id: java-ssrf-urlconnection
    message: 'SSRF vulnerability: User input in URL connection'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: new URL($URL + ...).openConnection()
          - pattern: new URL(... + $VAR + ...).openConnection()
    metadata:
      category: ssrf
      cwe: CWE-918
      owasp: A10:2021
      solution: |
        Validate URLs against allowlists and check for internal addresses:
        
        // Instead of:
        String userUrl = request.getParameter("url");
        URLConnection conn = new URL(userUrl).openConnection();
        
        // Use:
        String userUrl = request.getParameter("url");
        URL url = new URL(userUrl);
        
        // Validate protocol and host
        if (!"https".equals(url.getProtocol())) {
            throw new IllegalArgumentException("Only HTTPS allowed");
        }
        
        Set<String> allowedHosts = Set.of("api.trusted.com", "service.partner.com");
        if (!allowedHosts.contains(url.getHost())) {
            throw new IllegalArgumentException("Host not allowed");
        }
        
        // Check for internal IP ranges
        InetAddress addr = InetAddress.getByName(url.getHost());
        if (addr.isLoopbackAddress() || addr.isLinkLocalAddress() || addr.isSiteLocalAddress()) {
            throw new IllegalArgumentException("Internal addresses not allowed");
        }
        
        URLConnection conn = url.openConnection();

  - id: java-ssrf-httpclient
    message: 'SSRF vulnerability: User input in HTTP client request'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: new HttpGet($URL + ...)
          - pattern: new HttpPost($URL + ...)
    metadata:
      category: ssrf
      cwe: CWE-918
      solution: |
        Validate URLs and use allowlisted destinations:
        
        // Instead of:
        String userUrl = request.getParameter("url");
        HttpGet httpGet = new HttpGet(userUrl);
        
        // Use:
        String endpoint = request.getParameter("endpoint");
        Map<String, String> allowedEndpoints = Map.of(
            "users", "https://api.trusted.com/users",
            "orders", "https://api.trusted.com/orders"
        );
        
        String url = allowedEndpoints.get(endpoint);
        if (url == null) {
            throw new IllegalArgumentException("Invalid endpoint");
        }
        
        HttpGet httpGet = new HttpGet(url);

  - id: java-method-invoke-unsafe
    message: 'Reflection vulnerability: User input in Method.invoke()'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $METHOD.invoke($OBJ, $USER_INPUT)
          - pattern: $METHOD.invoke($OBJ, ..., $USER_INPUT, ...)
      # Exclude methods with proper validation
      - pattern-not-inside: |
          if ($USER_INPUT == null || $USER_INPUT.length() > $NUM || !$USER_INPUT.matches($REGEX)) {
            throw new IllegalArgumentException(...);
          }
          ...
          $METHOD.invoke($OBJ, $USER_INPUT);
      - pattern-not-inside: |
          if ($USER_INPUT == null || !$USER_INPUT.matches($REGEX)) {
            throw new IllegalArgumentException(...);
          }
          ...
          $METHOD.invoke($OBJ, ..., $USER_INPUT, ...);
    metadata:
      category: reflection
      cwe: CWE-470
      solution: |
        Validate method names and arguments before reflection:
        
        // Safe approach:
        String userInput = request.getParameter("arg");
        
        // Validate input before reflection
        if (userInput.length() > 100 || !userInput.matches("[a-zA-Z0-9 ]+")) {
            throw new IllegalArgumentException("Invalid input");
        }
        
        Method method = target.getClass().getMethod("process", String.class);
        method.invoke(target, userInput);

  - id: java-constructor-newinstance-unsafe
    message: 'Reflection vulnerability: Unsafe class instantiation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $CLASS.newInstance()
          - pattern: $CONSTRUCTOR.newInstance($USER_INPUT)
      # Exclude validated constructors
      - pattern-not-inside: |
          if (!$ALLOWLIST.contains($CLASSNAME)) {
            throw new IllegalArgumentException(...);
          }
          ...
          $CONSTRUCTOR.newInstance();
      # Exclude fixed class constructors
      - pattern-not-inside: |
          Class<?> $VAR = $FIXED_CLASS.class;
          ...
          $CONSTRUCTOR.newInstance();
    metadata:
      category: reflection
      cwe: CWE-470
      solution: |
        Use Constructor.newInstance() with validation or avoid reflection:
        
        // Safe approach:
        String className = request.getParameter("class");
        Set<String> allowedClasses = Set.of("com.example.SafeClass");
        
        if (!allowedClasses.contains(className)) {
            throw new IllegalArgumentException("Class not allowed");
        }
        
        Class<?> clazz = Class.forName(className);
        Constructor<?> constructor = clazz.getDeclaredConstructor();
        Object obj = constructor.newInstance();

  - id: java-trust-boundary-servlet
    message: 'Trust boundary violation: User input used in reflection'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          String $VAR = request.getParameter(...);
          ...
      - pattern-either:
          - pattern: Class.forName($VAR)
          - pattern: $METHOD.invoke(..., $VAR, ...)
      # Exclude validated class names
      - pattern-not-inside: |
          String $VAR = request.getParameter(...);
          ...
          if (!$ALLOWLIST.contains($VAR)) {
            throw new IllegalArgumentException(...);
          }
          ...
          Class.forName($VAR);
      # Exclude validated method parameters  
      - pattern-not-inside: |
          String $VAR = request.getParameter(...);
          ...
          if ($VAR == null || !$VAR.matches($REGEX)) {
            throw new IllegalArgumentException(...);
          }
          ...
          $METHOD.invoke(..., $VAR, ...);
    metadata:
      category: trust-boundary
      cwe: CWE-470
      solution: |
        Validate class names and method parameters before reflection:
        
        // Safe approach:
        String className = request.getParameter("class");
        Set<String> allowedClasses = Set.of(
            "com.example.SafeClass1",
            "com.example.SafeClass2"
        );
        
        if (!allowedClasses.contains(className)) {
            throw new IllegalArgumentException("Class not allowed");
        }
        
        Class<?> clazz = Class.forName(className);

  - id: java-reflection-security-bypass
    message: 'Security risk: Bypassing access controls with reflection'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $FIELD.setAccessible(true)
          - pattern: $METHOD.setAccessible(true)
          - pattern: $CONSTRUCTOR.setAccessible(true)
      # Exclude methods with security manager permission checks
      - pattern-not-inside: |
          SecurityManager $SM = System.getSecurityManager();
          if ($SM != null) {
            $SM.checkPermission(...);
          }
          ...
          $FIELD.setAccessible(true);
      - pattern-not-inside: |
          SecurityManager $SM = System.getSecurityManager();
          if ($SM != null) {
            $SM.checkPermission(...);
          }
          ...
          $METHOD.setAccessible(true);
      - pattern-not-inside: |
          SecurityManager $SM = System.getSecurityManager();
          if ($SM != null) {
            $SM.checkPermission(...);
          }
          ...
          $CONSTRUCTOR.setAccessible(true);
    metadata:
      category: reflection
      cwe: CWE-470
      solution: |
        Avoid reflection or implement proper access controls:
        
        // Safe approach:
        // Use public methods when possible
        obj.setFieldValue(value);
        
        // If reflection is necessary, check permissions:
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new ReflectPermission("suppressAccessChecks"));
        }
        
        Field field = MyClass.class.getDeclaredField("privateField");
        field.setAccessible(true);

  - id: java-jndi-injection
    message: 'JNDI injection vulnerability: User input in JNDI lookup'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $CTX.lookup($NAME + ...)
          - pattern: new InitialContext().lookup($NAME + ...)
      # Exclude validated JNDI lookups
      - pattern-not-inside: |
          if (!$ALLOWLIST.contains($NAME)) {
            throw new IllegalArgumentException(...);
          }
          ...
          $CTX.lookup($NAME);
      - pattern-not-inside: |
          if ($ALLOWLIST.contains($NAME)) {
            ...
            $CTX.lookup($NAME);
          }
    metadata:
      category: jndi-injection
      cwe: CWE-74
      solution: |
        Validate JNDI names against allowlists and use local references only:
        
        // Safe approach:
        String serviceName = request.getParameter("service");
        Set<String> allowedServices = Set.of(
            "java:comp/env/jdbc/myDB",
            "java:comp/env/jms/queue"
        );
        
        if (!allowedServices.contains(serviceName)) {
            throw new IllegalArgumentException("Service not allowed");
        }
        
        Context ctx = new InitialContext();
        Object obj = ctx.lookup(serviceName);

  - id: java-rmi-security-bypass
    message: 'RMI security risk: User-controlled registry host'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: LocateRegistry.getRegistry($HOST + $SUFFIX)
          - pattern: LocateRegistry.getRegistry($HOST)
      - pattern-inside: |
          String $HOST = request.getParameter(...);
          ...
      # Exclude validated hosts
      - pattern-not-inside: |
          String $HOST = request.getParameter(...);
          ...
          if (!$ALLOWLIST.contains($HOST)) {
            ...
          }
          ...
          LocateRegistry.getRegistry($HOST);
      - pattern-not-inside: |
          String $HOST = request.getParameter(...);
          ...
          if ($ALLOWLIST.contains($HOST)) {
            ...
            LocateRegistry.getRegistry($HOST);
          }
    metadata:
      category: rmi
      cwe: CWE-20
      solution: |
        Use fixed registry hosts and validate RMI connections:
        
        // Safe approach:
        String configuredHost = System.getProperty("rmi.registry.host", "localhost");
        Registry registry = LocateRegistry.getRegistry(configuredHost);
        
        // Or validate against allowlist:
        String requestedHost = request.getParameter("host");
        Set<String> allowedHosts = Set.of("rmi-server1.internal", "rmi-server2.internal");
        
        if (allowedHosts.contains(requestedHost)) {
            Registry registry = LocateRegistry.getRegistry(requestedHost);
        }

  - id: java-spring-actuator-exposed
    message: 'Security risk: All Spring Boot Actuator endpoints exposed'
    languages:
      - java
    severity: WARNING
    pattern-regex: 'management\.endpoints\.web\.exposure\.include=\*'
    metadata:
      category: configuration
      cwe: CWE-200
      framework: spring-boot
      solution: |
        Limit actuator endpoint exposure and secure them properly:
        
        // Instead of:
        management.endpoints.web.exposure.include=*
        
        // Use:
        management.endpoints.web.exposure.include=health,info
        management.endpoint.health.show-details=when-authorized
        management.endpoints.web.base-path=/actuator
        management.security.enabled=true
        
        // Secure actuator endpoints:
        spring.security.user.name=admin
        spring.security.user.password=${ACTUATOR_PASSWORD}
        spring.security.user.roles=ACTUATOR

  - id: java-spring-security-debug
    message: 'Security risk: Spring Security debug mode enabled'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $X.debug(true)
          - pattern: $X.and().debug(true)
      - pattern-not-inside: |
          if ($CONDITION) {
            ...
          }
      - pattern-not-inside: |
          if (...) {
            ...
          }
    metadata:
      category: configuration
      framework: spring
      solution: |
        Disable debug mode in production environments:
        
        // Instead of:
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .anyRequest().authenticated()
                .and().debug(true);
        }
        
        // Use:
        @Value("${app.debug:false}")
        private boolean debugMode;
        
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            HttpSecurity config = http.authorizeRequests()
                .anyRequest().authenticated();
            
            if (debugMode && "development".equals(environment)) {
                config = config.and().debug(true);
            }
        }

  - id: java-api-rate-limit-missing
    message: 'API security risk: REST endpoint without rate limiting'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @RestController
          public class $CLASS {
            ...
          }
      - pattern: |
          @RequestMapping(...)
          public $TYPE $METHOD(...) {
            ...
          }
      # Exclude methods that have rate limiting
      - pattern-not-inside: |
          @RateLimited(...)
          @RequestMapping(...)
          public $TYPE $METHOD(...) {
            ...
          }
      - pattern-not-inside: |
          @RequestMapping(...)
          public $TYPE $METHOD(...) {
            ...
            rateLimitingService.$CALL(...);
            ...
          }
      - pattern-not-inside: |
          @RequestMapping(...)
          public $TYPE $METHOD(...) {
            ...
            if (!rateLimitingService.$CALL(...)) {
              ...
            }
            ...
          }
    metadata:
      category: rate-limiting
      cwe: CWE-770
      framework: spring
      solution: |
        Implement rate limiting for API endpoints:
        
        // Instead of:
        @RestController
        public class ApiController {
            @RequestMapping("/api/data")
            public ResponseEntity<String> getData() {
                return ResponseEntity.ok("data");
            }
        }
        
        // Use:
        @RestController
        public class ApiController {
            @RateLimited(requests = 100, duration = 60, unit = TimeUnit.SECONDS)
            @RequestMapping("/api/data")
            public ResponseEntity<String> getData() {
                return ResponseEntity.ok("data");
            }
        }
        
        // Or use Spring Cloud Gateway rate limiting:
        // spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=10,1s

  - id: java-hardcoded-password
    message: 'Security risk: Hardcoded password or secret detected'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: String $VAR = $VALUE;
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|passwd|pwd|secret|apiKey|api_key|authToken|auth_token).*
              - metavariable-regex:
                  metavariable: $VALUE
                  regex: |
                    "[a-zA-Z0-9!@#$%^&*()_+={}[\]:";'<>?,.\/]{6,}"
          - patterns:
              - pattern: String $VAR = $VALUE;  
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(key|token|credential).*
              - metavariable-regex:
                  metavariable: $VALUE
                  regex: |
                    "[a-zA-Z0-9+/]{20,}={0,2}"
    metadata:
      category: hardcoded-secrets
      cwe: CWE-798
      solution: |
        Use environment variables or secure configuration for secrets:
        
        // Instead of:
        String password = "mySecretPassword123";
        String apiKey = "abc123xyz789";
        
        // Use:
        String password = System.getenv("DATABASE_PASSWORD");
        String apiKey = System.getProperty("api.key");

  - id: java-security-manager-disabled
    message: 'Security risk: Security manager disabled'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: System.setSecurityManager(null)
    metadata:
      category: security-manager
      cwe: CWE-250
      solution: |
        Avoid disabling security manager:
        
        // Instead of:
        System.setSecurityManager(null);
        
        // Use:
        SecurityManager sm = new SecurityManager();
        System.setSecurityManager(sm);

  - id: java-system-exit
    message: 'Code quality: System.exit() call may terminate application unexpectedly'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern: System.exit(...)
    metadata:
      category: maintainability
      solution: |
        Use proper exception handling instead of System.exit():
        
        // Instead of:
        if (criticalError) {
            System.exit(1);
        }
        
        // Use:
        if (criticalError) {
            throw new RuntimeException("Critical system error");
        }

  - id: java-regex-dos
    message: 'ReDoS vulnerability: Catastrophic backtracking in regex pattern'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: Pattern.compile("(.*)*")
          - pattern: Pattern.compile("(.*)+")
          - pattern: Pattern.compile("(.+)*")
          - pattern: Pattern.compile("(.+)+")
          - pattern: Pattern.compile("(a*)*")
          - pattern: Pattern.compile("(a+)+")
    metadata:
      category: regex-dos
      cwe: CWE-1333
      solution: |
        Use non-backtracking regex patterns:
        
        // Instead of:
        Pattern pattern = Pattern.compile("(.*)*");
        Pattern pattern2 = Pattern.compile("(.+)+");
        
        // Use:
        Pattern pattern = Pattern.compile("[a-zA-Z0-9]*");
        Pattern pattern2 = Pattern.compile("\\w+");

  - id: java-sensitive-system-output
    message: 'Information disclosure: Sensitive data in system output'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: System.out.println($VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|key|secret|credential).*
          - patterns:
              - pattern: System.err.println($VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|key|secret|credential).*
          - patterns:
              - pattern: System.out.print($VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|key|secret|credential).*
    metadata:
      category: information-disclosure
      cwe: CWE-532
      solution: |
        Use proper logging framework and avoid sensitive data in output:
        
        // Instead of:
        System.out.println("User password: " + password);
        System.err.println("Database connection: " + dbUrl);
        
        // Use:
        // Use logger with proper levels
        logger.info("User authenticated successfully");
        logger.debug("Database connection established"); // Debug only
        
        // Never log sensitive data:
        logger.info("Processing payment for user ID: {}", userId);
        // Don't log: credit card, passwords, tokens, etc.

  - id: java-exception-sensitive-data
    message: 'Information disclosure: Exception details exposed to user'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              catch ($EXCEPTION $E) {
                ...
                $RESPONSE.getWriter().write($E.getMessage());
              }
          - pattern: |
              catch ($EXCEPTION $E) {
                ...
                return $E.getMessage();
              }
          - pattern: |
              catch ($EXCEPTION $E) {
                ...
                throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, $E.getMessage());
              }
    metadata:
      category: exception-handling
      cwe: CWE-209
      solution: |
        Return generic error messages and log detailed errors securely:
        
        // Instead of:
        try {
            // risky operation
        } catch (SQLException e) {
            response.getWriter().write(e.getMessage());
        }
        
        // Use:
        try {
            // risky operation
        } catch (SQLException e) {
            logger.error("Database error for user {}: {}", userId, e.getMessage());
            response.getWriter().write("An error occurred processing your request");
        }

  - id: java-debug-information-leak
    message: 'Information disclosure: Sensitive information in debug output'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: System.out.println("..." + $VAR + "...");
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|key|secret|credential|admin|database).*
          - patterns:
              - pattern: System.err.println("..." + $VAR + "...");
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|key|secret|credential|admin|database).*
    metadata:
      category: information-disclosure
      cwe: CWE-532
      solution: |
        Use proper logging framework and avoid exposing sensitive data in output:
        
        // Instead of:
        System.out.println("API key: " + apiKey);
        System.out.println("User password: " + password);
        System.out.println("Database connection: " + dbUrl);
        System.err.println("Error with user: " + userDetails);
        
        // Use proper logging with appropriate levels:
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;
        
        private static final Logger logger = LoggerFactory.getLogger(MyClass.class);
        
        // Log without sensitive data
        logger.debug("API key configured successfully");
        logger.info("User authentication attempted for user ID: {}", userId);
        logger.error("Database connection failed - check configuration");
        
        // Sanitize data before logging
        String sanitizedUser = userDetails.replaceAll("password=\\w+", "password=***");
        logger.debug("Processing user: {}", sanitizedUser);
        
        // Use appropriate log levels
        logger.trace("Detailed debugging info");  // Only in development
        logger.debug("Debug information");        // Development/staging
        logger.info("General information");       // Production safe
        logger.warn("Warning messages");          // Production safe
        logger.error("Error messages");           // Production safe

  - id: java-stack-trace-exposure
    message: 'Information disclosure: Stack trace or error message exposure'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $EXCEPTION.printStackTrace()
          - pattern: $RESPONSE.getWriter().write($EXCEPTION.getMessage())
          - pattern: $RESPONSE.getWriter().println($EXCEPTION.getMessage())
          - pattern: $EXCEPTION.printStackTrace($WRITER)
    metadata:
      category: exception-handling
      cwe: CWE-209
      solution: |
        Log errors securely and return generic error messages to users:
        
        // Instead of:
        try {
            // operation
        } catch (Exception e) {
            e.printStackTrace();
            response.getWriter().write(e.getMessage());
        }
        
        // Use:
        try {
            // operation
        } catch (Exception e) {
            logger.error("Error processing request for user {}: {}", userId, e.getMessage(), e);
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            response.getWriter().write("An internal error occurred");
        }

  - id: java-sensitive-data-exposure
    message: 'Data exposure risk: Sensitive field in serializable entity'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern-inside: |
              @Entity
              public class $CLASS {
                ...
                private String password;
                ...
              }
          - pattern-inside: |
              @Entity
              public class $CLASS {
                ...
                private String creditCard;
                ...
              }
          - pattern: |
              @JsonProperty
              private String $FIELD;
      - metavariable-regex:
          metavariable: $FIELD
          regex: .*(password|creditCard|ssn|token|secret).*
    metadata:
      category: serialization
      cwe: CWE-200
      framework: jpa
      solution: |
        Use DTOs for serialization and exclude sensitive fields:
        
        // Instead of:
        @Entity
        public class User {
            private String password;
            private String creditCard;
            // getters/setters
        }
        
        // Use:
        @Entity
        public class User {
            @JsonIgnore
            private String password;
            
            @JsonIgnore  
            private String creditCard;
        }
        
        // Better: Create separate DTO for API responses:
        public class UserDto {
            private String username;
            private String email;
            // Only non-sensitive fields
        }

  - id: java-sensitive-data-logging
    message: 'Information disclosure: Sensitive data in log messages'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: $LOGGER.info($MESSAGE + $VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|secret|token|creditCard|ssn).*
          - patterns:
              - pattern: $LOGGER.debug($MESSAGE + $VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|secret|token|creditCard|ssn).*
          - patterns:
              - pattern: $LOGGER.error($MESSAGE + $VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|secret|token|creditCard|ssn).*
    metadata:
      category: logging
      cwe: CWE-532
      solution: |
        Mask or exclude sensitive data from log messages:
        
        // Instead of:
        logger.info("Processing payment with card: " + creditCard);
        logger.debug("User password: " + password);
        
        // Use:
        logger.info("Processing payment with card: ****-****-****-{}", 
            creditCard.substring(creditCard.length() - 4));
        logger.debug("User authentication successful for: {}", username);
        
        // Create helper method for masking:
        public String maskSensitive(String value) {
            return value != null && value.length() > 4 ? 
                "***" + value.substring(value.length() - 4) : "***";
        }

  - id: java-log-injection
    message: 'Log injection vulnerability: Unvalidated user input in logs'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $LOGGER.info($USER_INPUT + ...)
          - pattern: $LOGGER.error($USER_INPUT + ...)
          - pattern: $LOGGER.debug($USER_INPUT + ...)
          - pattern: $LOGGER.warn($USER_INPUT + ...)
    metadata:
      category: log-injection
      cwe: CWE-117
      solution: |
        Sanitize user input before logging:
        
        // Instead of:
        String userInput = request.getParameter("data");
        logger.info("User submitted: " + userInput);
        
        // Use:
        String userInput = request.getParameter("data");
        String sanitizedInput = userInput.replaceAll("[\r\n\t]", "_");
        logger.info("User submitted: {}", sanitizedInput);
        
        // Or use structured logging:
        MDC.put("userId", userId);
        MDC.put("userAction", sanitizedAction);
        logger.info("User action completed");
        MDC.clear();

  - id: java-debug-mode-production
    message: 'Security risk: Debug logging enabled (may leak sensitive information)'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $LOGGER.setLevel(Level.DEBUG)
          - pattern: $LOGGER.setLevel(Level.ALL)
          - pattern: System.setProperty("java.util.logging.config.file", ...)
          - pattern: Logger.getRootLogger().setLevel(Level.DEBUG)
    metadata:
      category: logging
      cwe: CWE-489
      solution: |
        Use environment-based logging configuration and avoid debug in production:
        
        // Instead of:
        logger.setLevel(Level.DEBUG);
        
        // Use:
        // Configure logging in logback.xml or log4j2.xml based on environment
        String env = System.getenv("ENVIRONMENT");
        if ("development".equals(env)) {
            logger.setLevel(Level.DEBUG);
        } else {
            logger.setLevel(Level.INFO);
        }
        
        // Better: Use configuration files
        // In logback-spring.xml:
        // <springProfile name="production">
        //   <root level="WARN"/>
        // </springProfile>

  # ===========================================================================
  # 25. LDAP INJECTION
  # ===========================================================================

  - id: java-ldap-injection
    message: 'LDAP injection vulnerability: User input in LDAP search filter'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              $CONTEXT.search($BASE, "..." + $USER_INPUT + "...", $CONTROLS);
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              $CONTEXT.search($BASE, $USER_INPUT + "...", $CONTROLS);
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              $CONTEXT.search($BASE, "..." + $USER_INPUT, $CONTROLS);
    metadata:
      category: ldap-injection
      cwe: CWE-90
      solution: |
        Escape LDAP filter characters to prevent injection:
        
        // Instead of:
        String userFilter = request.getParameter("filter");
        ctx.search(baseDN, "(uid=" + userFilter + ")", searchControls);
        
        // Use:
        String userFilter = request.getParameter("filter");
        String escapedFilter = escapeLDAPFilter(userFilter);
        ctx.search(baseDN, "(uid=" + escapedFilter + ")", searchControls);
        
        // LDAP filter escaping method:
        public static String escapeLDAPFilter(String filter) {
            StringBuilder sb = new StringBuilder();
            for (char ch : filter.toCharArray()) {
                switch (ch) {
                    case '\\': sb.append("\\5c"); break;
                    case '*': sb.append("\\2a"); break;
                    case '(': sb.append("\\28"); break;
                    case ')': sb.append("\\29"); break;
                    case '\0': sb.append("\\00"); break;
                    default: sb.append(ch);
                }
            }
            return sb.toString();
        }

  - id: java-ldap-dn-injection
    message: 'LDAP DN injection: User input in Distinguished Name'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              $CONTEXT.lookup("cn=" + $USER_INPUT + ",...");
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              $CONTEXT.bind("cn=" + $USER_INPUT + ",...", $OBJ);
    metadata:
      category: ldap-injection
      cwe: CWE-90
      solution: |
        Escape DN components to prevent LDAP injection:
        
        // Instead of:
        String userCN = request.getParameter("cn");
        ctx.lookup("cn=" + userCN + ",ou=users,dc=example,dc=com");
        
        // Use:
        String userCN = request.getParameter("cn");
        String escapedCN = escapeLDAPDN(userCN);
        ctx.lookup("cn=" + escapedCN + ",ou=users,dc=example,dc=com");
        
        // DN escaping method:
        public static String escapeLDAPDN(String name) {
            StringBuilder sb = new StringBuilder();
            for (char ch : name.toCharArray()) {
                switch (ch) {
                    case '\\': sb.append("\\\\"); break;
                    case ',': sb.append("\\,"); break;
                    case '+': sb.append("\\+"); break;
                    case '"': sb.append("\\\""); break;
                    case '<': sb.append("\\<"); break;
                    case '>': sb.append("\\>"); break;
                    case ';': sb.append("\\;"); break;
                    case '=': sb.append("\\="); break;
                    case '\0': sb.append("\\00"); break;
                    default: sb.append(ch);
                }
            }
            return sb.toString();
        }

  # ===========================================================================
  # 26. WEAK ENCRYPTION EXTENDED
  # ===========================================================================

  - id: java-weak-encryption-des
    message: 'Weak encryption: DES algorithm is insecure'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: Cipher.getInstance("DES")
          - pattern: Cipher.getInstance("DES/...")
          - pattern: KeyGenerator.getInstance("DES")
    metadata:
      category: weak-encryption
      cwe: CWE-327
      solution: |
        Replace DES with AES encryption:
        
        // Instead of:
        Cipher cipher = Cipher.getInstance("DES");
        KeyGenerator keyGen = KeyGenerator.getInstance("DES");
        
        // Use:
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");

  - id: java-weak-encryption-3des
    message: 'Weak encryption: 3DES (Triple DES) is deprecated'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: Cipher.getInstance("DESede")
          - pattern: Cipher.getInstance("TripleDES")
          - pattern: Cipher.getInstance("3DES")
          - pattern: KeyGenerator.getInstance("DESede")
    metadata:
      category: weak-encryption
      cwe: CWE-327
      solution: |
        Replace 3DES with AES encryption:
        
        // Instead of:
        Cipher cipher = Cipher.getInstance("DESede");
        
        // Use:
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");

  - id: java-weak-encryption-rc4
    message: 'Weak encryption: RC4 algorithm has known vulnerabilities'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: Cipher.getInstance("RC4")
          - pattern: Cipher.getInstance("ARCFOUR")
    metadata:
      category: weak-encryption
      cwe: CWE-327
      solution: |
        Replace RC4 with secure stream ciphers or AES:
        
        // Instead of:
        Cipher cipher = Cipher.getInstance("RC4");
        
        // Use:
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");

  - id: java-weak-hash-md5
    message: 'Weak hashing: MD5 is cryptographically broken'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: MessageDigest.getInstance("MD5")
    metadata:
      category: weak-hashing
      cwe: CWE-327
      solution: |
        Replace MD5 with secure hash functions:
        
        // Instead of:
        MessageDigest md = MessageDigest.getInstance("MD5");
        
        // Use:
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        // Or for password hashing:
        // BCrypt.hashpw(password, BCrypt.gensalt(12));

  - id: java-weak-hash-sha1
    message: 'Weak hashing: SHA-1 is deprecated and insecure'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: MessageDigest.getInstance("SHA-1")
      - pattern: MessageDigest.getInstance("SHA1")
    metadata:
      category: weak-hashing
      cwe: CWE-327
      solution: |
        Replace SHA-1 with SHA-256 or higher:
        
        // Instead of:
        MessageDigest md = MessageDigest.getInstance("SHA-1");
        
        // Use:
        MessageDigest md = MessageDigest.getInstance("SHA-256");

  - id: java-weak-mac-md5
    message: 'Weak MAC: HMAC-MD5 uses insecure hash function'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: Mac.getInstance("HmacMD5")
    metadata:
      category: weak-mac
      cwe: CWE-327
      solution: |
        Replace HMAC-MD5 with HMAC-SHA256:
        
        // Instead of:
        Mac mac = Mac.getInstance("HmacMD5");
        
        // Use:
        Mac mac = Mac.getInstance("HmacSHA256");

  - id: java-weak-rsa-key-size
    message: 'Weak encryption: RSA key size too small'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: $KEYGEN.initialize($SIZE);
              - metavariable-comparison:
                  metavariable: $SIZE
                  comparison: $SIZE < 2048
          - patterns:
              - pattern: KeyPairGenerator.getInstance("RSA").initialize($SIZE);
              - metavariable-comparison:
                  metavariable: $SIZE
                  comparison: $SIZE < 2048
    metadata:
      category: weak-encryption
      cwe: CWE-326
      solution: |
        Use RSA key sizes of at least 2048 bits:
        
        // Instead of:
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(1024);
        
        // Use:
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048); // Minimum recommended
        // Or better: keyGen.initialize(3072); // Future-proof

  - id: java-weak-dsa-key-size
    message: 'Weak encryption: DSA key size too small'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: $KEYGEN.initialize($SIZE);
              - pattern-inside: |
                  KeyPairGenerator $KEYGEN = KeyPairGenerator.getInstance("DSA");
                  ...
              - metavariable-comparison:
                  metavariable: $SIZE
                  comparison: $SIZE < 2048
    metadata:
      category: weak-encryption
      cwe: CWE-326
      solution: |
        Use DSA key sizes of at least 2048 bits:
        
        // Instead of:
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
        keyGen.initialize(1024);
        
        // Use:
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
        keyGen.initialize(2048);

  - id: java-ecb-mode-encryption
    message: 'Weak encryption: ECB mode does not provide semantic security'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: Cipher.getInstance("AES/ECB/...")
          - pattern: Cipher.getInstance("DES/ECB/...")
          - pattern: Cipher.getInstance("DESede/ECB/...")
    metadata:
      category: weak-encryption
      cwe: CWE-327
      solution: |
        Use CBC or GCM mode instead of ECB:
        
        // Instead of:
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        
        // Use:
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        // Or:
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        // Remember to use random IV for CBC mode

  - id: java-no-padding-encryption
    message: 'Weak encryption: No padding can lead to information disclosure'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: Cipher.getInstance(".../NoPadding")
          - pattern: Cipher.getInstance("RSA")
    metadata:
      category: weak-encryption
      cwe: CWE-327
      solution: |
        Use appropriate padding for encryption algorithms:
        
        // Instead of:
        Cipher cipher = Cipher.getInstance("RSA/ECB/NoPadding");
        
        // Use:
        Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPPadding");
        // Or for AES:
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");

  # ===========================================================================
  # 27. BUSINESS LOGIC EXTENDED
  # ===========================================================================

  - id: java-insecure-random-password
    message: 'Weak security: Insecure random for password generation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          Random $RAND = new Random();
          ...
      - pattern-either:
          - pattern: |
              StringBuilder $PASS = new StringBuilder();
              ...
              $PASS.append($CHARS.charAt($RAND.nextInt(...)));
          - pattern: |
              String $PASS = ...;
              ...
              $PASS += $CHARS.charAt($RAND.nextInt(...));
    metadata:
      category: weak-randomness
      cwe: CWE-330
      solution: |
        Use SecureRandom for password generation:
        
        // Instead of:
        Random rand = new Random();
        StringBuilder password = new StringBuilder();
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (int i = 0; i < 12; i++) {
            password.append(chars.charAt(rand.nextInt(chars.length())));
        }
        
        // Use:
        SecureRandom secureRand = new SecureRandom();
        StringBuilder password = new StringBuilder();
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
        for (int i = 0; i < 12; i++) {
            password.append(chars.charAt(secureRand.nextInt(chars.length())));
        }

  - id: java-insecure-random-token
    message: 'Weak security: Insecure random for token generation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          Random $RAND = new Random();
          ...
      - pattern-either:
          - pattern: |
              byte[] $TOKEN = new byte[$SIZE];
              $RAND.nextBytes($TOKEN);
          - pattern: |
              String $TOKEN = ...;
              ...
              $TOKEN = Integer.toString($RAND.nextInt(...));
    metadata:
      category: weak-randomness
      cwe: CWE-330
      solution: |
        Use SecureRandom for security token generation:
        
        // Instead of:
        Random rand = new Random();
        byte[] token = new byte[32];
        rand.nextBytes(token);
        
        // Use:
        SecureRandom secureRand = new SecureRandom();
        byte[] token = new byte[32];
        secureRand.nextBytes(token);
        String tokenString = Base64.getEncoder().encodeToString(token);

  - id: java-timing-attack-string-compare
    message: 'Timing attack: Non-constant time string comparison'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              if ($SECRET.equals($USER_INPUT)) {
                ...
              }
          - pattern: |
              if ($USER_INPUT.equals($SECRET)) {
                ...
              }
      - metavariable-regex:
          metavariable: $SECRET
          regex: .*(password|token|secret|hash|key).*
    metadata:
      category: timing-attack
      cwe: CWE-208
      solution: |
        Use constant-time comparison for sensitive data:
        
        // Instead of:
        if (storedPassword.equals(userPassword)) {
            // authenticate
        }
        
        // Use:
        import java.security.MessageDigest;
        
        public static boolean constantTimeEquals(String a, String b) {
            if (a.length() != b.length()) {
                return false;
            }
            int result = 0;
            for (int i = 0; i < a.length(); i++) {
                result |= a.charAt(i) ^ b.charAt(i);
            }
            return result == 0;
        }
        
        if (constantTimeEquals(storedPasswordHash, userPasswordHash)) {
            // authenticate
        }

  - id: java-integer-overflow-multiplication
    message: 'Integer overflow: Multiplication without bounds checking'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              int $RESULT = $A * $B;
          - pattern: |
              long $RESULT = $A * $B;
      - pattern-inside: |
          $METHOD(..., int $A, int $B, ...) {
            ...
          }
    metadata:
      category: integer-overflow
      cwe: CWE-190
      solution: |
        Use Math.multiplyExact() or check for overflow:
        
        // Instead of:
        int result = a * b;
        
        // Use:
        try {
            int result = Math.multiplyExact(a, b);
        } catch (ArithmeticException e) {
            throw new IllegalArgumentException("Integer overflow in multiplication");
        }
        
        // Or manual check:
        if (a != 0 && (Integer.MAX_VALUE / a) < b) {
            throw new ArithmeticException("Integer overflow");
        }
        int result = a * b;

  - id: java-integer-overflow-addition
    message: 'Integer overflow: Addition without bounds checking'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              int $RESULT = $A + $B;
          - pattern: |
              long $RESULT = $A + $B;
      - pattern-inside: |
          $METHOD(..., int $A, int $B, ...) {
            ...
          }
    metadata:
      category: integer-overflow
      cwe: CWE-190
      solution: |
        Use Math.addExact() or check for overflow:
        
        // Instead of:
        int result = a + b;
        
        // Use:
        try {
            int result = Math.addExact(a, b);
        } catch (ArithmeticException e) {
            throw new IllegalArgumentException("Integer overflow in addition");
        }

  - id: java-discount-calculation-bypass
    message: 'Business logic: Discount calculation may allow negative values'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              $TOTAL = $PRICE - $DISCOUNT;
          - pattern: |
              $TOTAL = $PRICE * (1 - $DISCOUNT_PERCENT);
      - pattern-not-inside: |
          if ($DISCOUNT < 0 || $DISCOUNT > $PRICE) {
            ...
          }
      - pattern-not-inside: |
          if ($DISCOUNT_PERCENT < 0 || $DISCOUNT_PERCENT > 1) {
            ...
          }
    metadata:
      category: business-logic
      cwe: CWE-840
      solution: |
        Validate discount values to prevent negative totals:
        
        // Instead of:
        BigDecimal total = price.subtract(discount);
        
        // Use:
        if (discount.compareTo(BigDecimal.ZERO) < 0 || discount.compareTo(price) > 0) {
            throw new IllegalArgumentException("Invalid discount amount");
        }
        BigDecimal total = price.subtract(discount);
        
        // For percentage discounts:
        if (discountPercent < 0 || discountPercent > 100) {
            throw new IllegalArgumentException("Invalid discount percentage");
        }

  - id: java-quantity-manipulation
    message: 'Business logic: Quantity parameter without validation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              int $QUANTITY = Integer.parseInt(request.getParameter("quantity"));
              ...
              $TOTAL = $PRICE * $QUANTITY;
          - pattern: |
              BigDecimal $QUANTITY = new BigDecimal(request.getParameter("quantity"));
              ...
              $TOTAL = $PRICE.multiply($QUANTITY);
      - pattern-not-inside: |
          if ($QUANTITY <= 0 || $QUANTITY > $MAX_QUANTITY) {
            ...
          }
    metadata:
      category: business-logic
      cwe: CWE-840
      solution: |
        Validate quantity parameters to prevent manipulation:
        
        // Instead of:
        int quantity = Integer.parseInt(request.getParameter("quantity"));
        BigDecimal total = price.multiply(BigDecimal.valueOf(quantity));
        
        // Use:
        int quantity = Integer.parseInt(request.getParameter("quantity"));
        if (quantity <= 0 || quantity > MAX_QUANTITY) {
            throw new IllegalArgumentException("Invalid quantity: " + quantity);
        }
        BigDecimal total = price.multiply(BigDecimal.valueOf(quantity));

  # ===========================================================================
  # 28. ANDROID SECURITY EXTENDED
  # ===========================================================================

  - id: java-android-exported-component
    message: 'Android security: Exported component without permission'
    languages:
      - xml
    severity: WARNING
    patterns:
      - pattern-inside: |
          <$COMPONENT android:exported="true" ...>
            ...
          </$COMPONENT>
      - pattern-not-inside: |
          <$COMPONENT android:exported="true" android:permission="..." ...>
            ...
          </$COMPONENT>
    paths:
      include:
        - "**/AndroidManifest.xml"
    metadata:
      category: android-security
      cwe: CWE-926
      platform: android
      solution: |
        Add proper permissions to exported components:
        
        // Instead of:
        <activity android:exported="true" android:name=".MainActivity">
        
        // Use:
        <activity 
            android:exported="true" 
            android:name=".MainActivity"
            android:permission="com.example.CUSTOM_PERMISSION">

  - id: java-android-sql-injection
    message: 'Android SQL injection: Raw query with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: $DB.rawQuery("SELECT * FROM " + $TABLE + " WHERE " + $USER_INPUT, null)
          - pattern: $DB.execSQL("INSERT INTO " + $TABLE + " VALUES(" + $USER_INPUT + ")")
    metadata:
      category: android-sql-injection
      cwe: CWE-89
      platform: android
      solution: |
        Use parameterized queries for Android SQLite:
        
        // Instead of:
        String userInput = getIntent().getStringExtra("query");
        Cursor cursor = db.rawQuery("SELECT * FROM users WHERE name = " + userInput, null);
        
        // Use:
        String userInput = getIntent().getStringExtra("query");
        Cursor cursor = db.rawQuery("SELECT * FROM users WHERE name = ?", new String[]{userInput});

  - id: java-android-insecure-storage
    message: 'Android insecure storage: Sensitive data in SharedPreferences'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $PREFS.edit().putString("password", $PASSWORD).commit();
          - pattern: $PREFS.edit().putString("token", $TOKEN).apply();
          - pattern: $PREFS.edit().putString("secret", $SECRET).commit();
    metadata:
      category: android-insecure-storage
      cwe: CWE-200
      platform: android
      solution: |
        Use Android Keystore or encrypted SharedPreferences:
        
        // Instead of:
        SharedPreferences prefs = getSharedPreferences("MyPrefs", MODE_PRIVATE);
        prefs.edit().putString("password", userPassword).commit();
        
        // Use encrypted SharedPreferences:
        MasterKeys.AES256_GCM_SPEC masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);
        SharedPreferences encryptedPrefs = EncryptedSharedPreferences.create(
            "encrypted_prefs",
            masterKeyAlias,
            context,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        );
        encryptedPrefs.edit().putString("password", userPassword).apply();

  - id: java-android-world-writable-files
    message: 'Android insecure storage: World-writable files'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: openFileOutput($FILENAME, MODE_WORLD_WRITABLE)
          - pattern: openFileOutput($FILENAME, MODE_WORLD_READABLE)
    metadata:
      category: android-insecure-storage
      cwe: CWE-732
      platform: android
      solution: |
        Use private file modes or internal storage:
        
        // Instead of:
        FileOutputStream fos = openFileOutput("sensitive.txt", MODE_WORLD_WRITABLE);
        
        // Use:
        FileOutputStream fos = openFileOutput("sensitive.txt", MODE_PRIVATE);
        
        // Or use internal storage:
        File internalDir = getFilesDir();
        File file = new File(internalDir, "sensitive.txt");
        FileOutputStream fos = new FileOutputStream(file);

  - id: java-android-external-storage-sensitive
    message: 'Android insecure storage: Sensitive data on external storage'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              File $FILE = new File(Environment.getExternalStorageDirectory(), $FILENAME);
              ...
              FileOutputStream $FOS = new FileOutputStream($FILE);
          - pattern: |
              File $DIR = getExternalFilesDir(...);
              File $FILE = new File($DIR, $FILENAME);
      - metavariable-regex:
          metavariable: $FILENAME
          regex: .*(password|token|secret|key|credential).*
    metadata:
      category: android-insecure-storage
      cwe: CWE-200
      platform: android
      solution: |
        Store sensitive data on internal storage only:
        
        // Instead of:
        File externalFile = new File(Environment.getExternalStorageDirectory(), "secrets.txt");
        FileOutputStream fos = new FileOutputStream(externalFile);
        
        // Use:
        File internalFile = new File(getFilesDir(), "secrets.txt");
        FileOutputStream fos = new FileOutputStream(internalFile);

  - id: java-android-debug-log-sensitive
    message: 'Android security: Sensitive data in debug logs'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - patterns:
              - pattern: Log.d($TAG, $MESSAGE + $VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|secret|key|credential).*
          - patterns:
              - pattern: Log.v($TAG, $MESSAGE + $VAR + ...);
              - metavariable-regex:
                  metavariable: $VAR
                  regex: .*(password|token|secret|key|credential).*
    metadata:
      category: android-logging
      cwe: CWE-532
      platform: android
      solution: |
        Remove sensitive data from logs and use conditional logging:
        
        // Instead of:
        Log.d(TAG, "User password: " + password);
        Log.d(TAG, "API token: " + apiToken);
        
        // Use:
        if (BuildConfig.DEBUG) {
            Log.d(TAG, "User authentication successful");
            Log.d(TAG, "API token configured");
        }
        
        // Or use log levels appropriately:
        Log.i(TAG, "Processing payment for user ID: " + userId);
        // Never log: Log.d(TAG, "Credit card: " + creditCard);

  - id: java-android-certificate-pinning-bypass
    message: 'Android security: Certificate pinning bypass detected'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                  ...
                  public void checkClientTrusted(X509Certificate[] chain, String authType) {}
                  public void checkServerTrusted(X509Certificate[] chain, String authType) {}
                  ...
                }
              };
          - pattern: |
              HostnameVerifier allHostsValid = new HostnameVerifier() {
                public boolean verify(String hostname, SSLSession session) {
                  return true;
                }
              };
    metadata:
      category: android-ssl
      cwe: CWE-295
      platform: android
      solution: |
        Implement proper certificate validation:
        
        // Instead of:
        TrustManager[] trustAllCerts = new TrustManager[] {
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType) {}
                public void checkServerTrusted(X509Certificate[] chain, String authType) {}
                public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }
            }
        };
        
        // Use:
        // Implement proper certificate pinning
        CertificatePinner certificatePinner = new CertificatePinner.Builder()
            .add("api.trusted.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
            .build();
        
        OkHttpClient client = new OkHttpClient.Builder()
            .certificatePinner(certificatePinner)
            .build();

  # ===========================================================================
  # 29. FORMAT INJECTION EXTENDED
  # ===========================================================================

  - id: java-format-injection-logger
    message: 'Format injection: Logger with user-controlled format string'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $FORMAT = request.getParameter(...);
              ...
          - pattern-either:
              - pattern: $LOGGER.info($FORMAT, ...)
              - pattern: $LOGGER.debug($FORMAT, ...)
              - pattern: $LOGGER.error($FORMAT, ...)
              - pattern: $LOGGER.warn($FORMAT, ...)
    metadata:
      category: format-injection
      cwe: CWE-134
      solution: |
        Use fixed format strings and parameterized logging:
        
        // Instead of:
        String userFormat = request.getParameter("logFormat");
        logger.info(userFormat, userData);
        
        // Use:
        String userData = request.getParameter("data");
        logger.info("User submitted data: {}", userData);

  - id: java-date-format-injection
    message: 'Format injection: SimpleDateFormat with user pattern'
    languages:
      - java
    severity: WARNING
    patterns:
      - patterns:
          - pattern-inside: |
              String $PATTERN = request.getParameter(...);
              ...
          - pattern: new SimpleDateFormat($PATTERN).format($DATE)
    metadata:
      category: format-injection
      cwe: CWE-134
      solution: |
        Use predefined date format patterns:
        
        // Instead of:
        String userPattern = request.getParameter("datePattern");
        String formatted = new SimpleDateFormat(userPattern).format(new Date());
        
        // Use:
        Map<String, String> allowedFormats = Map.of(
            "short", "MM/dd/yyyy",
            "long", "MMMM dd, yyyy",
            "iso", "yyyy-MM-dd"
        );
        String formatType = request.getParameter("formatType");
        String pattern = allowedFormats.getOrDefault(formatType, "yyyy-MM-dd");
        String formatted = new SimpleDateFormat(pattern).format(new Date());

  # ===========================================================================
  # 30. ADDITIONAL NETWORK SECURITY
  # ===========================================================================

  - id: java-trust-all-ssl-contexts
    message: 'SSL security: Trust-all SSL context disables certificate validation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              SSLContext $CTX = SSLContext.getInstance("TLS");
              $CTX.init(null, new TrustManager[]{$TRUST_ALL}, new SecureRandom());
          - pattern: |
              HttpsURLConnection.setDefaultSSLSocketFactory($CTX.getSocketFactory());
              HttpsURLConnection.setDefaultHostnameVerifier(($HOSTNAME, $SESSION) -> true);
    metadata:
      category: ssl-security
      cwe: CWE-295
      solution: |
        Use proper SSL context with certificate validation:
        
        // Instead of:
        SSLContext ctx = SSLContext.getInstance("TLS");
        ctx.init(null, trustAllCerts, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
        
        // Use:
        SSLContext ctx = SSLContext.getDefault(); // Uses system trust store
        HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
        HttpsURLConnection.setDefaultHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());

  - id: java-ftp-plain-credentials
    message: 'Network security: FTP credentials transmitted in plain text'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $FTP.login($USER, $PASS)
          - pattern: new FTPClient().connect($HOST)
    metadata:
      category: network-security
      cwe: CWE-319
      solution: |
        Use SFTP or FTPS instead of plain FTP:
        
        // Instead of:
        FTPClient ftpClient = new FTPClient();
        ftpClient.connect(server);
        ftpClient.login(username, password);
        
        // Use SFTP:
        JSch jsch = new JSch();
        Session session = jsch.getSession(username, server, 22);
        session.setPassword(password);
        session.setConfig("StrictHostKeyChecking", "yes");
        session.connect();

  - id: java-smtp-plain-credentials
    message: 'Network security: SMTP credentials without encryption'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          # Pattern for PasswordAuthentication usage
          - patterns:
              - pattern: new PasswordAuthentication($USER, $PASS)
              - pattern-inside: |
                  Session $SESSION = Session.getInstance($PROPS, ...);
          # Pattern for simple SMTP properties without encryption
          - patterns:
              - pattern: $PROPS.put("mail.smtp.host", $HOST)
              - pattern-not-inside: |
                  $PROPS.put("mail.smtp.starttls.enable", "true");
          # Pattern for Session.getInstance with Authenticator
          - patterns:
              - pattern: Session.getInstance($PROPS, new Authenticator() { ... })
              - pattern-not-inside: |
                  $PROPS.put("mail.smtp.starttls.enable", "true");
    metadata:
      category: network-security
      cwe: CWE-319
      solution: |
        Enable STARTTLS for SMTP connections:
        
        // Instead of:
        Properties props = new Properties();
        props.put("mail.smtp.host", "smtp.example.com");
        Session session = Session.getInstance(props, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("user", "password");
            }
        });
        
        // Use:
        Properties props = new Properties();
        props.put("mail.smtp.host", "smtp.example.com");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.smtp.ssl.trust", "smtp.example.com");
        props.put("mail.smtp.port", "587");
        Session session = Session.getInstance(props, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("user", "password");
            }
        });

  - id: java-insecure-protocol-usage
    message: 'Network security: Insecure protocol usage detected'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: new URL("http://...")
          - pattern: new URL("ftp://...")
          - pattern: new URL("telnet://...")
    metadata:
      category: network-security
      cwe: CWE-319
      solution: |
        Use secure protocols (HTTPS, SFTP, SSH):
        
        // Instead of:
        URL url = new URL("http://api.example.com/data");
        
        // Use:
        URL url = new URL("https://api.example.com/data");
        
        // For file transfers, use SFTP instead of FTP
        // For remote access, use SSH instead of Telnet

  # ===========================================================================
  # 31. STRUTS FRAMEWORK SECURITY
  # ===========================================================================

  - id: java-struts-ognl-injection
    message: 'OGNL injection: Struts Action with OGNL expression evaluation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $EXPR = request.getParameter(...);
              ...
              Ognl.getValue($EXPR, $CONTEXT, $ROOT);
          - pattern: |
              String $EXPR = request.getParameter(...);
              ...
              OgnlContext.setExpression($EXPR);
    metadata:
      category: struts-ognl
      cwe: CWE-94
      framework: struts
      solution: |
        Avoid dynamic OGNL expression evaluation with user input:
        
        // Instead of:
        String userExpr = request.getParameter("expression");
        Object result = Ognl.getValue(userExpr, context, root);
        
        // Use:
        // Use predefined, safe expressions or avoid OGNL entirely
        String action = request.getParameter("action");
        switch (action) {
            case "getUser":
                return userService.getCurrentUser();
            case "getProfile":
                return userService.getUserProfile();
            default:
                throw new IllegalArgumentException("Invalid action");
        }

  - id: java-struts-validation-bypass
    message: 'Struts validation bypass: Action without validation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          public class $CLASS extends ActionSupport {
            ...
          }
      - pattern: |
          public String $METHOD() {
            ...
            return SUCCESS;
          }
      - pattern-not-inside: |
          @Validations(...)
          public String $METHOD() {
            ...
          }
      - pattern-not-inside: |
          public String $METHOD() {
            ...
            if (!validate()) {
              return INPUT;
            }
            ...
          }
    metadata:
      category: struts-validation
      cwe: CWE-20
      framework: struts
      solution: |
        Add proper validation to Struts actions:
        
        // Instead of:
        public String execute() {
            // Process without validation
            return SUCCESS;
        }
        
        // Use:
        @Validations(
            requiredStrings = {
                @RequiredStringValidator(fieldName = "username", message = "Username required"),
                @RequiredStringValidator(fieldName = "email", message = "Email required")
            },
            emails = {
                @EmailValidator(fieldName = "email", message = "Invalid email format")
            }
        )
        public String execute() {
            // Process with validation
            return SUCCESS;
        }

  - id: java-struts-file-upload-vulnerability
    message: 'Struts file upload: Unrestricted file upload'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          public class $CLASS extends ActionSupport {
            ...
            private File $UPLOAD;
            ...
          }
      - pattern: |
          public String $METHOD() {
            ...
            Files.copy($UPLOAD.toPath(), $DEST);
            ...
          }
      - pattern-not-inside: |
          if (!$ALLOWED_TYPES.contains($CONTENT_TYPE)) {
            ...
          }
    metadata:
      category: struts-file-upload
      cwe: CWE-434
      framework: struts
      solution: |
        Validate file types and sizes in Struts file uploads:
        
        // Instead of:
        public String upload() {
            Path dest = Paths.get("/uploads/" + uploadFileName);
            Files.copy(upload.toPath(), dest);
            return SUCCESS;
        }
        
        // Use:
        public String upload() {
            // Validate file type
            Set<String> allowedTypes = Set.of("image/jpeg", "image/png", "application/pdf");
            if (!allowedTypes.contains(uploadContentType)) {
                addFieldError("upload", "Invalid file type");
                return INPUT;
            }
            
            // Validate file size (configured in struts.xml)
            if (upload.length() > MAX_FILE_SIZE) {
                addFieldError("upload", "File too large");
                return INPUT;
            }
            
            // Sanitize filename
            String safeFileName = Paths.get(uploadFileName).getFileName().toString();
            Path dest = Paths.get("/secure/uploads/" + UUID.randomUUID() + "_" + safeFileName);
            Files.copy(upload.toPath(), dest);
            return SUCCESS;
        }

  # ===========================================================================
  # 32. JSF FRAMEWORK SECURITY
  # ===========================================================================

  - id: java-jsf-expression-injection
    message: 'JSF EL injection: Expression Language injection in managed bean'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $EXPR = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get(...);
              ...
              $APP.evaluateExpressionGet($CONTEXT, "#{" + $EXPR + "}", Object.class);
          - pattern: |
              String $EXPR = $REQUEST.getParameter(...);
              ...
              $EL_RESOLVER.getValue($EL_CONTEXT, null, $EXPR);
    metadata:
      category: jsf-el-injection
      cwe: CWE-94
      framework: jsf
      solution: |
        Avoid dynamic EL expression construction with user input:
        
        // Instead of:
        String userExpr = facesContext.getExternalContext().getRequestParameterMap().get("expr");
        Object result = application.evaluateExpressionGet(facesContext, "#{" + userExpr + "}", Object.class);
        
        // Use:
        String property = facesContext.getExternalContext().getRequestParameterMap().get("property");
        Map<String, String> allowedProperties = Map.of(
            "userName", "#{userBean.name}",
            "userEmail", "#{userBean.email}"
        );
        
        if (allowedProperties.containsKey(property)) {
            Object result = application.evaluateExpressionGet(facesContext, allowedProperties.get(property), Object.class);
        }

  - id: java-jsf-viewstate-tampering
    message: 'JSF security: ViewState parameter tampering possible'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @ManagedBean
          public class $CLASS {
            ...
          }
      - pattern: |
          public $TYPE $METHOD() {
            ...
            $FIELD = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get(...);
            ...
          }
    metadata:
      category: jsf-viewstate
      cwe: CWE-472
      framework: jsf
      solution: |
        Enable ViewState encryption and validation:
        
        // In web.xml:
        <context-param>
            <param-name>com.sun.faces.enableViewStateIdRendering</param-name>
            <param-value>true</param-value>
        </context-param>
        <context-param>
            <param-name>com.sun.faces.clientStateWriteThreshold</param-name>
            <param-value>-1</param-value>
        </context-param>
        
        // Use server-side state saving:
        <context-param>
            <param-name>javax.faces.STATE_SAVING_METHOD</param-name>
            <param-value>server</param-value>
        </context-param>

  # ===========================================================================
  # 33. HIBERNATE/JPA SECURITY EXTENDED
  # ===========================================================================

  - id: java-hibernate-hql-injection
    message: 'HQL injection: Hibernate Query Language injection vulnerability'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $HQL = "FROM User WHERE name = '" + $USER_INPUT + "'";
              $SESSION.createQuery($HQL);
          - pattern: |
              Query $QUERY = $SESSION.createQuery("FROM User WHERE id = " + $USER_ID);
    metadata:
      category: hibernate-hql-injection
      cwe: CWE-89
      framework: hibernate
      solution: |
        Use parameterized HQL queries:
        
        // Instead of:
        String userName = request.getParameter("name");
        String hql = "FROM User WHERE name = '" + userName + "'";
        Query query = session.createQuery(hql);
        
        // Use:
        String userName = request.getParameter("name");
        String hql = "FROM User WHERE name = :name";
        Query query = session.createQuery(hql);
        query.setParameter("name", userName);

  - id: java-jpa-criteria-injection
    message: 'JPA Criteria injection: User input in dynamic criteria query'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              String $FIELD = request.getParameter(...);
              ...
              $BUILDER.equal($ROOT.get($FIELD), $VALUE);
          - pattern: |
              String $FIELD = request.getParameter(...);
              ...
              $ROOT.get($FIELD);
    metadata:
      category: jpa-criteria
      cwe: CWE-89
      framework: jpa
      solution: |
        Validate field names against allowlists in Criteria queries:
        
        // Instead of:
        String fieldName = request.getParameter("field");
        Predicate predicate = builder.equal(root.get(fieldName), value);
        
        // Use:
        String fieldName = request.getParameter("field");
        Set<String> allowedFields = Set.of("name", "email", "status");
        
        if (!allowedFields.contains(fieldName)) {
            throw new IllegalArgumentException("Invalid field: " + fieldName);
        }
        
        Predicate predicate = builder.equal(root.get(fieldName), value);

  - id: java-hibernate-session-injection
    message: 'Hibernate SQL injection: Native SQL query with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $SQL = "SELECT * FROM users WHERE name = '" + $USER_INPUT + "'";
              $SESSION.createSQLQuery($SQL);
          - pattern: |
              $SESSION.createNativeQuery("SELECT * FROM " + $TABLE + " WHERE id = " + $ID);
    metadata:
      category: hibernate-sql-injection
      cwe: CWE-89
      framework: hibernate
      solution: |
        Use parameterized native queries:
        
        // Instead of:
        String tableName = request.getParameter("table");
        String sql = "SELECT * FROM " + tableName + " WHERE active = 1";
        Query query = session.createSQLQuery(sql);
        
        // Use:
        String sql = "SELECT * FROM users WHERE active = 1 AND name = :name";
        Query query = session.createSQLQuery(sql);
        query.setParameter("name", userName);
        
        // For table names, use allowlist validation:
        Map<String, String> allowedTables = Map.of("users", "users", "orders", "orders");
        String table = allowedTables.get(request.getParameter("table"));
        if (table != null) {
            String sql = "SELECT * FROM " + table + " WHERE active = 1";
            // This is safe as table name comes from allowlist
        }

  # ===========================================================================
  # 34. ADDITIONAL SERIALIZATION VULNERABILITIES
  # ===========================================================================

  - id: java-java-serialization-gadget
    message: 'Java deserialization: Potential gadget chain in classpath'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: new ObjectInputStream($INPUT).readObject()
          - pattern: $OIS.readObject()
      - pattern-inside: |
          ObjectInputStream $OIS = new ObjectInputStream(...);
          ...
    metadata:
      category: java-deserialization
      cwe: CWE-502
      solution: |
        Implement ObjectInputFilter to restrict deserialization:
        
        // Instead of:
        ObjectInputStream ois = new ObjectInputStream(inputStream);
        Object obj = ois.readObject();
        
        // Use:
        ObjectInputStream ois = new ObjectInputStream(inputStream);
        
        // Set up input filter (Java 9+)
        ois.setObjectInputFilter(info -> {
            if (info.serialClass() != null) {
                String className = info.serialClass().getName();
                // Allow only specific classes
                Set<String> allowedClasses = Set.of(
                    "com.example.SafeClass",
                    "java.lang.String",
                    "java.lang.Integer"
                );
                
                if (allowedClasses.contains(className)) {
                    return ObjectInputFilter.Status.ALLOWED;
                }
                
                // Block dangerous classes
                if (className.startsWith("org.apache.commons.collections") ||
                    className.contains("InvokerTransformer")) {
                    return ObjectInputFilter.Status.REJECTED;
                }
            }
            
            return ObjectInputFilter.Status.UNDECIDED;
        });
        
        Object obj = ois.readObject();

  - id: java-rmi-deserialization
    message: 'RMI deserialization: Unsafe RMI object deserialization'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              Registry $REGISTRY = LocateRegistry.getRegistry(...);
              $SERVICE = ($TYPE) $REGISTRY.lookup(...);
          - pattern: |
              $RMI_OBJECT = ($TYPE) Naming.lookup(...);
    metadata:
      category: rmi-deserialization
      cwe: CWE-502
      solution: |
        Use RMI with security manager and restricted classes:
        
        // Instead of:
        Registry registry = LocateRegistry.getRegistry("untrusted-host", 1099);
        MyService service = (MyService) registry.lookup("MyService");
        
        // Use:
        // Set up security manager
        if (System.getSecurityManager() == null) {
            System.setSecurityManager(new SecurityManager());
        }
        
        // Use local registry only or validate hosts
        Registry registry = LocateRegistry.getRegistry("localhost", 1099);
        MyService service = (MyService) registry.lookup("MyService");

  - id: java-xmldecoder-deserialization
    message: 'XMLDecoder deserialization: Unsafe XML deserialization'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: new XMLDecoder($INPUT).readObject()
          - pattern: |
              XMLDecoder $DECODER = new XMLDecoder($INPUT);
              $DECODER.readObject();
    metadata:
      category: xml-deserialization
      cwe: CWE-502
      solution: |
        Avoid XMLDecoder with untrusted input or implement strict validation:
        
        // Instead of:
        XMLDecoder decoder = new XMLDecoder(untrustedInputStream);
        Object obj = decoder.readObject();
        
        // Use:
        // Prefer safe data formats like JSON
        ObjectMapper mapper = new ObjectMapper();
        MyClass obj = mapper.readValue(jsonString, MyClass.class);
        
        // If XMLDecoder is necessary, validate XML structure first
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        // Additional XML validation...

  # ===========================================================================
  # 35. ADVANCED FILE OPERATIONS SECURITY
  # ===========================================================================

  - id: java-file-inclusion-vulnerability
    message: 'File inclusion: Dynamic file inclusion with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $FILE = request.getParameter(...);
              ...
              Files.readString(Paths.get($FILE));
          - pattern: |
              String $FILE = request.getParameter(...);
              ...
              new Scanner(new File($FILE));
          - pattern: |
              String $FILE = request.getParameter(...);
              ...
              Files.newBufferedReader(Paths.get($FILE));
    metadata:
      category: file-inclusion
      cwe: CWE-98
      solution: |
        Validate file paths against allowlists and use secure base directories:
        
        // Instead of:
        String fileName = request.getParameter("file");
        String content = Files.readString(Paths.get(fileName));
        
        // Use:
        String fileName = request.getParameter("file");
        
        // Validate against allowlist
        Set<String> allowedFiles = Set.of("config.properties", "readme.txt", "help.html");
        if (!allowedFiles.contains(fileName)) {
            throw new IllegalArgumentException("File not allowed: " + fileName);
        }
        
        // Use secure base directory
        Path basePath = Paths.get("/secure/files");
        Path filePath = basePath.resolve(fileName).normalize();
        
        // Ensure file is within base directory
        if (!filePath.startsWith(basePath)) {
            throw new SecurityException("Path traversal attempt");
        }
        
        String content = Files.readString(filePath);

  - id: java-temporary-file-security
    message: 'Temporary file security: Insecure temporary file creation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: File.createTempFile($PREFIX, $SUFFIX)
          - pattern: new File(System.getProperty("java.io.tmpdir"), $FILENAME)
    metadata:
      category: temporary-files
      cwe: CWE-379
      solution: |
        Create temporary files with secure permissions:
        
        // Instead of:
        File tempFile = File.createTempFile("temp", ".txt");
        
        // Use:
        Path tempFile = Files.createTempFile("temp", ".txt");
        
        // Set secure permissions (owner only)
        Set<PosixFilePermission> permissions = EnumSet.of(
            PosixFilePermission.OWNER_READ,
            PosixFilePermission.OWNER_WRITE
        );
        Files.setPosixFilePermissions(tempFile, permissions);
        
        // Or use try-with-resources for automatic cleanup:
        try (FileWriter writer = Files.newBufferedWriter(tempFile)) {
            writer.write(sensitiveData);
        } finally {
            Files.deleteIfExists(tempFile);
        }

  - id: java-file-permissions-too-open
    message: 'File permissions: Overly permissive file permissions set'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: Files.setPosixFilePermissions($PATH, PosixFilePermissions.fromString("rwxrwxrwx"))
          - pattern: Files.setPosixFilePermissions($PATH, PosixFilePermissions.fromString("rw-rw-rw-"))
          - pattern: $FILE.setReadable(true, false)
          - pattern: $FILE.setWritable(true, false)
    metadata:
      category: file-permissions
      cwe: CWE-732
      solution: |
        Set restrictive file permissions (owner only):
        
        // Instead of:
        Files.setPosixFilePermissions(path, PosixFilePermissions.fromString("rwxrwxrwx"));
        file.setReadable(true, false);
        
        // Use:
        Set<PosixFilePermission> restrictivePerms = EnumSet.of(
            PosixFilePermission.OWNER_READ,
            PosixFilePermission.OWNER_WRITE
        );
        Files.setPosixFilePermissions(path, restrictivePerms);
        
        // Or for legacy File API:
        file.setReadable(true, true);  // Owner only
        file.setWritable(true, true);  // Owner only

  - id: java-file-race-condition
    message: 'File race condition: TOCTOU vulnerability in file operations'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          if (Files.exists($PATH)) {
            ...
            Files.delete($PATH);
          }
      - pattern: |
          if (!Files.exists($PATH)) {
            ...
            Files.createFile($PATH);
          }
    metadata:
      category: race-condition
      cwe: CWE-367
      solution: |
        Use atomic file operations to prevent TOCTOU race conditions:
        
        // Instead of:
        if (Files.exists(path)) {
            Files.delete(path);
        }
        
        // Use:
        try {
            Files.delete(path);
        } catch (NoSuchFileException e) {
            // File didn't exist, which is fine
        }
        
        // For file creation:
        try {
            Files.createFile(path);
        } catch (FileAlreadyExistsException e) {
            // File already exists, handle appropriately
        }

  # ===========================================================================
  # 36. ADDITIONAL CRYPTOGRAPHIC VULNERABILITIES
  # ===========================================================================

  - id: java-predictable-seed-random
    message: 'Cryptographic weakness: Predictable seed for Random'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: new Random(System.currentTimeMillis())
          - pattern: new Random($CONSTANT)
          - pattern: new Random(0)
    metadata:
      category: predictable-randomness
      cwe: CWE-330
      solution: |
        Use SecureRandom without predictable seeds:
        
        // Instead of:
        Random rand = new Random(System.currentTimeMillis());
        Random rand2 = new Random(12345);
        
        // Use:
        SecureRandom secureRand = new SecureRandom();
        // SecureRandom automatically uses unpredictable seed
        
        // If you need Random for non-security purposes:
        Random rand = new Random(); // Uses default seeding

  - id: java-static-iv-encryption
    message: 'Cryptographic flaw: Static or hardcoded IV/nonce'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              byte[] $IV = { ... };
              IvParameterSpec $IV_SPEC = new IvParameterSpec($IV);
          - pattern: |
              IvParameterSpec $IV_SPEC = new IvParameterSpec("...".getBytes());
          - pattern: |
              GCMParameterSpec $GCM_SPEC = new GCMParameterSpec($TAG_LENGTH, "...".getBytes());
    metadata:
      category: static-iv
      cwe: CWE-323
      solution: |
        Generate random IV/nonce for each encryption:
        
        // Instead of:
        byte[] iv = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        
        // Use:
        SecureRandom secureRandom = new SecureRandom();
        byte[] iv = new byte[16]; // AES block size
        secureRandom.nextBytes(iv);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        
        // For GCM mode:
        byte[] nonce = new byte[12]; // GCM nonce size
        secureRandom.nextBytes(nonce);
        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce);

  - id: java-weak-tls-version
    message: 'Cryptographic weakness: Weak TLS protocol version'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: SSLContext.getInstance("SSL")
          - pattern: SSLContext.getInstance("SSLv3")
          - pattern: SSLContext.getInstance("TLSv1")
          - pattern: SSLContext.getInstance("TLSv1.1")
    metadata:
      category: weak-tls
      cwe: CWE-327
      solution: |
        Use modern TLS versions (1.2 or higher):
        
        // Instead of:
        SSLContext context = SSLContext.getInstance("TLSv1");
        
        // Use:
        SSLContext context = SSLContext.getInstance("TLSv1.2");
        // Or better:
        SSLContext context = SSLContext.getInstance("TLS"); // Uses highest available
        
        // For Java 11+:
        SSLContext context = SSLContext.getInstance("TLSv1.3");

  - id: java-insecure-cipher-suite
    message: 'Cryptographic weakness: Insecure cipher suite enabled'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $SSL_SOCKET.setEnabledCipherSuites($SUITES)
          - pattern: $SSL_ENGINE.setEnabledCipherSuites($SUITES)
      - metavariable-regex:
          metavariable: $SUITES
          regex: '.*(?:NULL|EXPORT|RC4|DES|MD5).*'
    metadata:
      category: insecure-cipher-suite
      cwe: CWE-327
      solution: |
        Use secure cipher suites only:
        
        // Instead of:
        String[] weakCiphers = {"SSL_RSA_WITH_NULL_MD5", "SSL_RSA_EXPORT_WITH_RC4_40_MD5"};
        sslSocket.setEnabledCipherSuites(weakCiphers);
        
        // Use:
        String[] strongCiphers = {
            "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"
        };
        sslSocket.setEnabledCipherSuites(strongCiphers);
        
        // Or let the system choose secure defaults:
        // sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());

  - id: java-certificate-without-validation
    message: 'SSL/TLS vulnerability: X509TrustManager that accepts all certificates'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          new X509TrustManager() {
            ...
            public void checkClientTrusted(X509Certificate[] chain, String authType) {}
            public void checkServerTrusted(X509Certificate[] chain, String authType) {}
            ...
          }
    metadata:
      category: ssl-validation
      cwe: CWE-295
      solution: |
        Implement proper certificate validation:
        
        // Instead of:
        X509TrustManager trustManager = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) {}
            public void checkServerTrusted(X509Certificate[] chain, String authType) {}
            public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
        };
        
        // Use:
        // Use default trust manager with system trust store
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init((KeyStore) null);
        TrustManager[] trustManagers = tmf.getTrustManagers();
        
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, trustManagers, new SecureRandom());

  # ===========================================================================
  # 37. RACE CONDITIONS AND CONCURRENCY EXTENDED
  # ===========================================================================

  - id: java-lazy-initialization-race
    message: 'Race condition: Unsafe lazy initialization'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          if ($FIELD == null) {
            $FIELD = new $TYPE(...);
          }
      - pattern-not-inside: |
          synchronized ($LOCK) {
            ...
          }
      - pattern-not-inside: |
          synchronized (this) {
            ...
          }
    metadata:
      category: lazy-initialization-race
      cwe: CWE-362
      solution: |
        Use proper synchronization for lazy initialization:
        
        // Instead of:
        public ExpensiveObject getExpensiveObject() {
            if (expensiveObject == null) {
                expensiveObject = new ExpensiveObject();
            }
            return expensiveObject;
        }
        
        // Use:
        public synchronized ExpensiveObject getExpensiveObject() {
            if (expensiveObject == null) {
                expensiveObject = new ExpensiveObject();
            }
            return expensiveObject;
        }
        
        // Or use initialization-on-demand holder pattern:
        private static class Holder {
            static final ExpensiveObject INSTANCE = new ExpensiveObject();
        }
        
        public ExpensiveObject getExpensiveObject() {
            return Holder.INSTANCE;
        }

  - id: java-check-then-act-race
    message: 'Race condition: Check-then-act race condition'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          if ($MAP.containsKey($KEY)) {
            $VALUE = $MAP.get($KEY);
          }
      - pattern: |
          if (!$MAP.isEmpty()) {
            $ELEMENT = $MAP.remove($KEY);
          }
    metadata:
      category: check-then-act-race
      cwe: CWE-362
      solution: |
        Use atomic operations to avoid race conditions:
        
        // Instead of:
        if (map.containsKey(key)) {
            value = map.get(key);
        }
        
        // Use:
        value = map.get(key);
        if (value != null) {
            // Process value
        }
        
        // Or for ConcurrentHashMap:
        value = concurrentMap.computeIfPresent(key, (k, v) -> {
            // Atomic operation
            return processValue(v);
        });

  - id: java-iterator-concurrent-modification
    message: 'Concurrent modification: Iterator used while collection is modified'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          for ($TYPE $ITEM : $COLLECTION) {
            ...
          }
      - pattern-either:
          - pattern: $COLLECTION.add(...)
          - pattern: $COLLECTION.remove(...)
          - pattern: $COLLECTION.clear()
    metadata:
      category: concurrent-modification
      cwe: CWE-362
      solution: |
        Use thread-safe collections or proper synchronization:
        
        // Instead of:
        for (String item : list) {
            if (condition) {
                list.remove(item); // ConcurrentModificationException
            }
        }
        
        // Use:
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String item = iterator.next();
            if (condition) {
                iterator.remove(); // Safe removal
            }
        }
        
        // Or use concurrent collections:
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        for (String item : queue) {
            if (condition) {
                queue.remove(item); // Thread-safe
            }
        }

  - id: java-synchronized-this-exposure
    message: 'Concurrency issue: Synchronizing on this may cause external interference'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          synchronized (this) {
            ...
          }
      - pattern: |
          public synchronized $TYPE $METHOD(...) {
            ...
          }
    metadata:
      category: synchronization-exposure
      cwe: CWE-662
      solution: |
        Use private lock objects for synchronization:
        
        // Instead of:
        public synchronized void method() {
            // synchronized on this
        }
        
        synchronized (this) {
            // External code can interfere
        }
        
        // Use:
        private final Object lock = new Object();
        
        public void method() {
            synchronized (lock) {
                // Private lock, no external interference
            }
        }

  # ===========================================================================
  # 38. ADDITIONAL INPUT VALIDATION
  # ===========================================================================

  - id: java-url-validation-bypass
    message: 'Input validation bypass: URL validation can be bypassed'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              if ($URL.startsWith("http://trusted.com")) {
                ...
              }
          - pattern: |
              if ($URL.contains("trusted.com")) {
                ...
              }
    metadata:
      category: url-validation-bypass
      cwe: CWE-20
      solution: |
        Use proper URL parsing and validation:
        
        // Instead of:
        String userUrl = request.getParameter("url");
        if (userUrl.startsWith("http://trusted.com")) {
            // This can be bypassed with http://trusted.com.evil.com
        }
        
        // Use:
        String userUrl = request.getParameter("url");
        try {
            URL url = new URL(userUrl);
            Set<String> allowedHosts = Set.of("trusted.com", "api.trusted.com");
            
            if (allowedHosts.contains(url.getHost()) && 
                "https".equals(url.getProtocol())) {
                // Safe to proceed
            } else {
                throw new IllegalArgumentException("Invalid URL");
            }
        } catch (MalformedURLException e) {
            throw new IllegalArgumentException("Invalid URL format");
        }

  - id: java-email-validation-bypass
    message: 'Input validation bypass: Weak email validation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $EMAIL.contains("@")
          - pattern: $EMAIL.matches(".*@.*")
          - pattern: $EMAIL.indexOf("@") > 0
    metadata:
      category: email-validation-bypass
      cwe: CWE-20
      solution: |
        Use proper email validation:
        
        // Instead of:
        if (email.contains("@")) {
            // Weak validation, can be bypassed
        }
        
        // Use:
        String emailRegex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        Pattern emailPattern = Pattern.compile(emailRegex);
        
        if (emailPattern.matcher(email).matches()) {
            // Proper email validation
        }
        
        // Or use dedicated email validation library:
        // EmailValidator.getInstance().isValid(email)

  - id: java-ip-address-validation-bypass
    message: 'Input validation bypass: Weak IP address validation'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $IP.matches("\\d+\\.\\d+\\.\\d+\\.\\d+")
          - pattern: $IP.split("\\.").length == 4
    metadata:
      category: ip-validation-bypass
      cwe: CWE-20
      solution: |
        Use proper IP address validation:
        
        // Instead of:
        if (ip.matches("\\d+\\.\\d+\\.\\d+\\.\\d+")) {
            // This allows 999.999.999.999
        }
        
        // Use:
        try {
            InetAddress addr = InetAddress.getByName(ip);
            if (addr instanceof Inet4Address) {
                // Valid IPv4 address
            }
        } catch (UnknownHostException e) {
            throw new IllegalArgumentException("Invalid IP address");
        }
        
        // Or validate ranges manually:
        String[] parts = ip.split("\\.");
        if (parts.length == 4) {
            for (String part : parts) {
                int octet = Integer.parseInt(part);
                if (octet < 0 || octet > 255) {
                    throw new IllegalArgumentException("Invalid IP address");
                }
            }
        }

  - id: java-phone-validation-bypass
    message: 'Input validation bypass: Insufficient phone number validation'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-either:
          - pattern: $PHONE.matches("\\d+")
          - pattern: $PHONE.replaceAll("[^0-9]", "")
    metadata:
      category: phone-validation
      cwe: CWE-20
      solution: |
        Use comprehensive phone number validation:
        
        // Instead of:
        if (phone.matches("\\d+")) {
            // Too permissive
        }
        
        // Use:
        String phonePattern = "^\\+?[1-9]\\d{1,14}$"; // E.164 format
        if (phone.matches(phonePattern)) {
            // Basic international format validation
        }
        
        // Better: Use libphonenumber library
        PhoneNumberUtil phoneUtil = PhoneNumberUtil.getInstance();
        try {
            PhoneNumber phoneNumber = phoneUtil.parse(phone, "US");
            if (phoneUtil.isValidNumber(phoneNumber)) {
                // Valid phone number
            }
        } catch (NumberParseException e) {
            throw new IllegalArgumentException("Invalid phone number");
        }

  # ===========================================================================
  # 39. WEB SERVICES SECURITY
  # ===========================================================================

  - id: java-soap-xml-bomb
    message: 'XML bomb attack: SOAP service vulnerable to XML entity expansion'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-inside: |
          @WebService
          public class $CLASS {
            ...
          }
      - pattern: |
          @WebMethod
          public $TYPE $METHOD($PARAM_TYPE $PARAM) {
            ...
          }
      - pattern-not-inside: |
          $DBF.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
          ...
    metadata:
      category: soap-security
      cwe: CWE-776
      framework: soap
      solution: |
        Configure SOAP services to prevent XML entity expansion attacks:
        
        // Configure DocumentBuilderFactory in SOAP handler:
        public class SecureSOAPHandler implements SOAPHandler<SOAPMessageContext> {
            @Override
            public boolean handleMessage(SOAPMessageContext context) {
                try {
                    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
                    dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
                    dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
                    dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
                    dbf.setXIncludeAware(false);
                    dbf.setExpandEntityReferences(false);
                    
                    // Process SOAP message safely
                    return true;
                } catch (ParserConfigurationException e) {
                    return false;
                }
            }
        }

  - id: java-wsdl-information-disclosure
    message: 'Information disclosure: WSDL exposes internal service details'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-inside: |
          @WebService(wsdlLocation = $LOCATION)
          public class $CLASS {
            ...
          }
      - pattern: |
          @WebMethod
          public $TYPE $METHOD() throws $EXCEPTION {
            ...
          }
    metadata:
      category: soap-information-disclosure
      cwe: CWE-200
      framework: soap
      solution: |
        Minimize information exposure in WSDL and error messages:
        
        // Instead of:
        @WebService(wsdlLocation = "http://internal-server/service?wsdl")
        public class UserService {
            @WebMethod
            public User getUser() throws DatabaseException, InternalSystemException {
                // Exposes internal exceptions
            }
        }
        
        // Use:
        @WebService
        public class UserService {
            @WebMethod
            public User getUser() throws ServiceException {
                try {
                    // Internal logic
                    return user;
                } catch (Exception e) {
                    logger.error("Error in getUser", e);
                    throw new ServiceException("Service temporarily unavailable");
                }
            }
        }

  - id: java-rest-endpoint-enumeration
    message: 'Information disclosure: REST endpoint enumeration possible'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-inside: |
          @RestController
          @RequestMapping("/api/v1")
          public class $CLASS {
            ...
          }
      - pattern: |
          @GetMapping("/{id}")
          public $TYPE $METHOD(@PathVariable String id) {
            return $SERVICE.findById(Long.parseLong(id));
          }
    metadata:
      category: rest-enumeration
      cwe: CWE-200
      framework: spring
      solution: |
        Implement proper access controls and avoid sequential IDs:
        
        // Instead of:
        @GetMapping("/{id}")
        public User getUser(@PathVariable String id) {
            return userService.findById(Long.parseLong(id));
        }
        
        // Use:
        @GetMapping("/{id}")
        public User getUser(@PathVariable String id, Authentication auth) {
            UUID userId = UUID.fromString(id); // Use UUIDs instead of sequential IDs
            User user = userService.findById(userId);
            
            // Verify ownership
            if (!user.getOwner().equals(auth.getName()) && 
                !auth.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
                throw new AccessDeniedException("Access denied");
            }
            
            return user;
        }

  - id: java-graphql-query-depth
    message: 'DoS vulnerability: GraphQL query depth limit not enforced'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @Component
          public class $CLASS implements GraphQLQueryResolver {
            ...
          }
      - pattern: |
          public $TYPE $METHOD($...ARGS) {
            return $SERVICE.$CALL($...ARGS);
          }
      - pattern-not-inside: |
          @PreAuthorize(...)
          public $TYPE $METHOD($...ARGS) {
            ...
          }
    metadata:
      category: graphql-dos
      cwe: CWE-400
      framework: graphql
      solution: |
        Implement GraphQL query depth and complexity limits:
        
        // Configure GraphQL with limits:
        @Configuration
        public class GraphQLConfig {
            @Bean
            public GraphQLServlet graphQLServlet() {
                return GraphQLServlet.builder(graphQLSchema)
                    .add(new MaxQueryDepthInstrumentation(10))
                    .add(new MaxQueryComplexityInstrumentation(1000))
                    .build();
            }
        }
        
        // Add authorization to resolvers:
        @PreAuthorize("hasRole('USER')")
        public List<User> getUsers(@Argument int first, @Argument String after) {
            if (first > 100) { // Limit page size
                throw new IllegalArgumentException("Page size too large");
            }
            return userService.getUsers(first, after);
        }

  # ===========================================================================
  # 40. ADDITIONAL SPRING FRAMEWORK SECURITY
  # ===========================================================================

  - id: java-spring-data-query-injection
    message: 'Query injection: Spring Data query with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              @Query("SELECT u FROM User u WHERE u.name = '" + $PARAM + "'")
              List<User> $METHOD($PARAM_TYPE $PARAM);
          - pattern: |
              @Query(value = "SELECT * FROM users WHERE name = '" + $PARAM + "'", nativeQuery = true)
              List<User> $METHOD($PARAM_TYPE $PARAM);
    metadata:
      category: spring-data-injection
      cwe: CWE-89
      framework: spring-data
      solution: |
        Use parameterized queries in Spring Data:
        
        // Instead of:
        @Query("SELECT u FROM User u WHERE u.name = '" + name + "'")
        List<User> findByName(String name);
        
        // Use:
        @Query("SELECT u FROM User u WHERE u.name = :name")
        List<User> findByName(@Param("name") String name);
        
        // Or use method name queries:
        List<User> findByNameContaining(String name);

  - id: java-spring-expression-injection
    message: 'SpEL injection: Spring Expression Language in @Value annotation'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              @Value("#{" + $USER_INPUT + "}")
              private String $FIELD;
          - pattern: |
              @Value($USER_EXPR)
              private String $FIELD;
      - metavariable-regex:
          metavariable: $USER_EXPR
          regex: '.*#\{.*\+.*\}.*'
    metadata:
      category: spring-spel-injection
      cwe: CWE-94
      framework: spring
      solution: |
        Use static expressions in @Value annotations:
        
        // Instead of:
        @Value("#{request.getParameter('config')}")
        private String configValue;
        
        // Use:
        @Value("${app.config.value}")
        private String configValue;
        
        // Or inject the request and validate:
        @Autowired
        private HttpServletRequest request;
        
        @PostConstruct
        public void init() {
            String userConfig = request.getParameter("config");
            Set<String> allowedConfigs = Set.of("dev", "prod", "test");
            if (allowedConfigs.contains(userConfig)) {
                this.configValue = userConfig;
            }
        }

  - id: java-spring-method-security-bypass
    message: 'Authorization bypass: Spring method security not applied'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @Service
          public class $CLASS {
            ...
          }
      - pattern: |
          public void delete$ENTITY(Long id) {
            $REPOSITORY.deleteById(id);
          }
      - pattern-not-inside: |
          @PreAuthorize(...)
          public void delete$ENTITY(Long id) {
            ...
          }
    metadata:
      category: spring-method-security
      cwe: CWE-862
      framework: spring
      solution: |
        Apply method-level security annotations:
        
        // Instead of:
        @Service
        public class UserService {
            public void deleteUser(Long id) {
                userRepository.deleteById(id);
            }
        }
        
        // Use:
        @Service
        public class UserService {
            @PreAuthorize("hasRole('ADMIN') or @userService.isOwner(authentication.name, #id)")
            public void deleteUser(Long id) {
                userRepository.deleteById(id);
            }
            
            public boolean isOwner(String username, Long userId) {
                User user = userRepository.findById(userId).orElse(null);
                return user != null && user.getUsername().equals(username);
            }
        }

  - id: java-spring-transaction-rollback-missing
    message: 'Transaction management: Missing rollback for security-critical operations'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @Transactional
          public $TYPE $METHOD($...ARGS) {
            ...
          }
      - pattern-either:
          - pattern: |
              if (!$AUTH_CHECK) {
                throw new SecurityException(...);
              }
          - pattern: |
              if (!$PERMISSION_CHECK) {
                throw new AccessDeniedException(...);
              }
      - pattern-not-inside: |
          @Transactional(rollbackFor = {SecurityException.class, AccessDeniedException.class})
          public $TYPE $METHOD($...ARGS) {
            ...
          }
    metadata:
      category: spring-transaction
      cwe: CWE-404
      framework: spring
      solution: |
        Configure transaction rollback for security exceptions:
        
        // Instead of:
        @Transactional
        public void processPayment(PaymentRequest request) {
            if (!securityService.isAuthorized(request)) {
                throw new SecurityException("Unauthorized");
            }
            // Payment processing continues...
        }
        
        // Use:
        @Transactional(rollbackFor = {SecurityException.class, AccessDeniedException.class})
        public void processPayment(PaymentRequest request) {
            if (!securityService.isAuthorized(request)) {
                throw new SecurityException("Unauthorized");
            }
            // Payment processing - will rollback if security exception
        }

  # ===========================================================================
  # 41. MICROSERVICES SECURITY
  # ===========================================================================

  - id: java-service-to-service-no-auth
    message: 'Microservice security: Service-to-service communication without authentication'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              @FeignClient(url = $URL)
              public interface $CLIENT {
                @GetMapping(...)
                $TYPE $METHOD($...ARGS);
              }
          - pattern: |
              RestTemplate $TEMPLATE = new RestTemplate();
              $TEMPLATE.getForObject($INTERNAL_URL, $TYPE.class);
    metadata:
      category: microservice-security
      cwe: CWE-306
      framework: microservices
      solution: |
        Implement service-to-service authentication:
        
        // Instead of:
        @FeignClient(url = "http://user-service")
        public interface UserServiceClient {
            @GetMapping("/users/{id}")
            User getUser(@PathVariable Long id);
        }
        
        // Use:
        @FeignClient(url = "http://user-service", configuration = AuthConfiguration.class)
        public interface UserServiceClient {
            @GetMapping("/users/{id}")
            User getUser(@PathVariable Long id);
        }
        
        @Configuration
        public class AuthConfiguration {
            @Bean
            public RequestInterceptor requestInterceptor() {
                return template -> {
                    String token = jwtTokenProvider.createServiceToken();
                    template.header("Authorization", "Bearer " + token);
                };
            }
        }

  - id: java-circuit-breaker-missing
    message: 'Microservice resilience: Missing circuit breaker for external service calls'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-either:
          - pattern: |
              @FeignClient(...)
              public interface $CLIENT {
                @GetMapping(...)
                $TYPE $METHOD($...ARGS);
              }
          - pattern: |
              $TEMPLATE.getForObject($EXTERNAL_URL, $TYPE.class);
      - pattern-not-inside: |
          @CircuitBreaker(...)
          public $TYPE $METHOD($...ARGS) {
            ...
          }
    metadata:
      category: microservice-resilience
      cwe: CWE-400
      framework: microservices
      solution: |
        Add circuit breakers for external service calls:
        
        // Add circuit breaker annotation:
        @Component
        public class UserServiceClient {
            
            @CircuitBreaker(name = "user-service", fallbackMethod = "fallbackGetUser")
            @TimeLimiter(name = "user-service")
            public CompletableFuture<User> getUser(Long id) {
                return CompletableFuture.supplyAsync(() -> 
                    restTemplate.getForObject("/users/" + id, User.class));
            }
            
            public CompletableFuture<User> fallbackGetUser(Long id, Exception e) {
                return CompletableFuture.supplyAsync(() -> {
                    // Return cached data or default user
                    return userCache.get(id).orElse(User.defaultUser());
                });
            }
        }

  - id: java-service-mesh-bypass
    message: 'Service mesh security: Direct service communication bypassing mesh'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              RestTemplate $TEMPLATE = new RestTemplate();
              $TEMPLATE.getForObject("http://$SERVICE_IP:$PORT/...", ...);
          - pattern: |
              HttpURLConnection $CONN = (HttpURLConnection) new URL("http://$SERVICE_IP:$PORT/...").openConnection();
    metadata:
      category: service-mesh-security
      cwe: CWE-923
      framework: microservices
      solution: |
        Use service discovery and mesh-managed communication:
        
        // Instead of:
        RestTemplate restTemplate = new RestTemplate();
        String response = restTemplate.getForObject("http://192.168.1.10:8080/api/data", String.class);
        
        // Use:
        @LoadBalanced
        RestTemplate restTemplate = new RestTemplate();
        String response = restTemplate.getForObject("http://user-service/api/data", String.class);
        
        // Or use service discovery:
        @Autowired
        private DiscoveryClient discoveryClient;
        
        public String callUserService() {
            List<ServiceInstance> instances = discoveryClient.getInstances("user-service");
            if (!instances.isEmpty()) {
                ServiceInstance instance = instances.get(0);
                String url = instance.getUri() + "/api/data";
                return restTemplate.getForObject(url, String.class);
            }
            throw new ServiceUnavailableException("User service not available");
        }

  # ===========================================================================
  # 42. CONTAINER SECURITY
  # ===========================================================================

  - id: java-docker-secrets-in-env
    message: 'Container security: Secrets exposed in environment variables'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: System.getenv("DB_PASSWORD")
          - pattern: System.getenv("API_KEY")
          - pattern: System.getenv("SECRET_KEY")
          - pattern: System.getenv("PRIVATE_KEY")
    metadata:
      category: container-security
      cwe: CWE-200
      platform: docker
      solution: |
        Use Docker secrets or mounted secret files instead of environment variables:
        
        // Instead of:
        String dbPassword = System.getenv("DB_PASSWORD");
        
        // Use Docker secrets:
        String dbPassword = readDockerSecret("db_password");
        
        private String readDockerSecret(String secretName) {
            try {
                Path secretPath = Paths.get("/run/secrets/" + secretName);
                return Files.readString(secretPath).trim();
            } catch (IOException e) {
                throw new RuntimeException("Failed to read Docker secret: " + secretName, e);
            }
        }
        
        // Or use external secret management:
        @Value("${spring.datasource.password}")
        private String dbPassword; // Injected from Kubernetes secrets

  - id: java-kubernetes-service-account-default
    message: 'Kubernetes security: Using default service account'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-either:
          - pattern: |
              ApiClient $CLIENT = Config.defaultClient();
          - pattern: |
              KubernetesClient $CLIENT = new DefaultKubernetesClient();
    metadata:
      category: kubernetes-security
      cwe: CWE-250
      platform: kubernetes
      solution: |
        Use dedicated service accounts with minimal permissions:
        
        // Instead of:
        ApiClient client = Config.defaultClient();
        
        // Use:
        // Create dedicated service account in Kubernetes:
        // kubectl create serviceaccount my-app-service-account
        // kubectl create clusterrole my-app-role --verb=get,list --resource=pods
        // kubectl create clusterrolebinding my-app-binding --clusterrole=my-app-role --serviceaccount=default:my-app-service-account
        
        ApiClient client = Config.fromCluster();
        // Application will use the service account specified in deployment

  # ===========================================================================
  # 43. ADDITIONAL LOGGING SECURITY
  # ===========================================================================

  - id: java-logging-configuration-external
    message: 'Logging security: External logging configuration allows code execution'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $CONFIG_URL = request.getParameter(...);
              LoggerContext $CONTEXT = (LoggerContext) LoggerFactory.getILoggerFactory();
              $CONTEXT.getConfigurationWatchListURL($CONFIG_URL);
          - pattern: |
              System.setProperty("logback.configurationFile", $USER_INPUT);
    metadata:
      category: logging-configuration
      cwe: CWE-94
      solution: |
        Use static logging configuration and avoid user-controlled config sources:
        
        // Instead of:
        String configUrl = request.getParameter("logConfig");
        System.setProperty("logback.configurationFile", configUrl);
        
        // Use:
        // Use static configuration files only
        // logback-spring.xml in classpath
        
        // Or validate configuration sources:
        String configType = request.getParameter("logLevel");
        Map<String, String> allowedLevels = Map.of(
            "debug", "DEBUG",
            "info", "INFO",
            "warn", "WARN"
        );
        
        if (allowedLevels.containsKey(configType)) {
            Logger rootLogger = LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
            if (rootLogger instanceof ch.qos.logback.classic.Logger) {
                ((ch.qos.logback.classic.Logger) rootLogger).setLevel(
                    Level.valueOf(allowedLevels.get(configType))
                );
            }
        }

  - id: java-log-forging
    message: 'Log forging: User input may forge log entries'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              $LOGGER.info("User action: " + $USER_INPUT);
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              System.out.println("LOG: " + $USER_INPUT);
    metadata:
      category: log-forging
      cwe: CWE-117
      solution: |
        Sanitize user input before logging to prevent log forging:
        
        // Instead of:
        String userAction = request.getParameter("action");
        logger.info("User action: " + userAction);
        
        // Use:
        String userAction = request.getParameter("action");
        String sanitizedAction = userAction.replaceAll("[\r\n\t]", "_")
                                          .replaceAll("[\\x00-\\x1f\\x7f]", ""); // Remove control characters
        logger.info("User action: {}", sanitizedAction);
        
        // Or use structured logging:
        MDC.put("userId", getCurrentUserId());
        MDC.put("action", sanitizedAction);
        MDC.put("timestamp", Instant.now().toString());
        logger.info("User performed action");
        MDC.clear();

  - id: java-logger-denial-of-service
    message: 'DoS vulnerability: Excessive logging without rate limiting'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          for ($TYPE $ITEM : $COLLECTION) {
            ...
          }
      - pattern-either:
          - pattern: $LOGGER.info(...)
          - pattern: $LOGGER.debug(...)
          - pattern: $LOGGER.error(...)
    metadata:
      category: logging-dos
      cwe: CWE-770
      solution: |
        Implement rate limiting or batch logging for loops:
        
        // Instead of:
        for (User user : users) {
            logger.info("Processing user: " + user.getId());
            processUser(user);
        }
        
        // Use:
        logger.info("Starting batch processing of {} users", users.size());
        int processed = 0;
        for (User user : users) {
            processUser(user);
            processed++;
            
            // Log progress periodically
            if (processed % 100 == 0) {
                logger.info("Processed {} of {} users", processed, users.size());
            }
        }
        logger.info("Completed processing {} users", processed);

  # ===========================================================================
  # 44. ADDITIONAL BUSINESS LOGIC VULNERABILITIES
  # ===========================================================================

  - id: java-time-of-check-time-of-use
    message: 'TOCTOU vulnerability: Time-of-check to time-of-use race condition'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          if ($ACCOUNT.getBalance().compareTo($AMOUNT) >= 0) {
            ...
            $ACCOUNT.setBalance($ACCOUNT.getBalance().subtract($AMOUNT));
          }
      - pattern-not-inside: |
          synchronized (...) {
            ...
          }
      - pattern-not-inside: |
          @Transactional(isolation = Isolation.SERIALIZABLE)
          public $TYPE $METHOD(...) {
            ...
          }
    metadata:
      category: toctou-vulnerability
      cwe: CWE-367
      solution: |
        Use atomic operations or serializable transactions:
        
        // Instead of:
        if (account.getBalance().compareTo(amount) >= 0) {
            // Time gap - race condition possible
            account.setBalance(account.getBalance().subtract(amount));
        }
        
        // Use:
        @Transactional(isolation = Isolation.SERIALIZABLE)
        public void withdraw(Long accountId, BigDecimal amount) {
            Account account = accountRepository.findById(accountId).orElseThrow();
            
            if (account.getBalance().compareTo(amount) >= 0) {
                account.setBalance(account.getBalance().subtract(amount));
                accountRepository.save(account);
            } else {
                throw new InsufficientFundsException("Insufficient balance");
            }
        }
        
        // Or use optimistic locking:
        @Entity
        public class Account {
            @Version
            private Long version;
            
            @Column(nullable = false)
            private BigDecimal balance;
            
            // Optimistic locking will prevent concurrent modifications
        }

  - id: java-negative-quantity-business-logic
    message: 'Business logic flaw: Negative quantity accepted in order processing'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              int $QUANTITY = Integer.parseInt(request.getParameter("quantity"));
              $ORDER.setQuantity($QUANTITY);
          - pattern: |
              BigDecimal $QUANTITY = new BigDecimal(request.getParameter("quantity"));
              $TOTAL = $PRICE.multiply($QUANTITY);
      - pattern-not-inside: |
          if ($QUANTITY <= 0) {
            throw ...;
          }
    metadata:
      category: negative-quantity
      cwe: CWE-840
      solution: |
        Validate quantity to ensure positive values:
        
        // Instead of:
        int quantity = Integer.parseInt(request.getParameter("quantity"));
        order.setQuantity(quantity);
        
        // Use:
        int quantity = Integer.parseInt(request.getParameter("quantity"));
        
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive: " + quantity);
        }
        
        if (quantity > MAX_QUANTITY_PER_ORDER) {
            throw new IllegalArgumentException("Quantity exceeds maximum allowed: " + MAX_QUANTITY_PER_ORDER);
        }
        
        order.setQuantity(quantity);

  - id: java-currency-precision-loss
    message: 'Business logic flaw: Currency calculation with floating point precision loss'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              double $PRICE = Double.parseDouble(request.getParameter(...));
              double $TOTAL = $PRICE * $QUANTITY;
          - pattern: |
              float $PRICE = Float.parseFloat(request.getParameter(...));
              float $TOTAL = $PRICE * $QUANTITY;
    metadata:
      category: currency-precision
      cwe: CWE-682
      solution: |
        Use BigDecimal for currency calculations:
        
        // Instead of:
        double price = Double.parseDouble(request.getParameter("price"));
        double total = price * quantity;
        
        // Use:
        BigDecimal price = new BigDecimal(request.getParameter("price"));
        BigDecimal quantity = BigDecimal.valueOf(quantityInt);
        BigDecimal total = price.multiply(quantity);
        
        // Set appropriate scale and rounding mode
        total = total.setScale(2, RoundingMode.HALF_UP);

  - id: java-coupon-replay-attack
    message: 'Business logic flaw: Coupon/discount code can be reused multiple times'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern: |
          String $COUPON = request.getParameter("coupon");
          ...
          if ($COUPON_SERVICE.isValid($COUPON)) {
            $DISCOUNT = $COUPON_SERVICE.getDiscount($COUPON);
          }
      - pattern-not-inside: |
          if ($COUPON_SERVICE.isUsed($COUPON)) {
            throw ...;
          }
      - pattern-not-inside: |
          $COUPON_SERVICE.markAsUsed($COUPON, $USER_ID);
    metadata:
      category: coupon-replay
      cwe: CWE-294
      solution: |
        Track coupon usage to prevent replay attacks:
        
        // Instead of:
        String couponCode = request.getParameter("coupon");
        if (couponService.isValid(couponCode)) {
            BigDecimal discount = couponService.getDiscount(couponCode);
            total = total.subtract(discount);
        }
        
        // Use:
        String couponCode = request.getParameter("coupon");
        String userId = getCurrentUserId();
        
        if (couponService.isValid(couponCode)) {
            if (couponService.isUsedByUser(couponCode, userId)) {
                throw new IllegalArgumentException("Coupon already used");
            }
            
            if (couponService.hasReachedUsageLimit(couponCode)) {
                throw new IllegalArgumentException("Coupon usage limit reached");
            }
            
            BigDecimal discount = couponService.getDiscount(couponCode);
            total = total.subtract(discount);
            
            // Mark as used atomically with order creation
            couponService.markAsUsed(couponCode, userId, orderId);
        }

  # ===========================================================================
  # 45. DATABASE SECURITY EXTENDED
  # ===========================================================================

  - id: java-database-connection-pooling-info
    message: 'Information disclosure: Database connection details in error messages'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern: |
          catch (SQLException $E) {
            ...
            $LOGGER.error("Database error: " + $E.getMessage());
          }
      - pattern: |
          catch (SQLException $E) {
            ...
            throw new RuntimeException($E.getMessage());
          }
    metadata:
      category: database-info-disclosure
      cwe: CWE-209
      solution: |
        Log detailed errors securely and return generic messages:
        
        // Instead of:
        try {
            // Database operation
        } catch (SQLException e) {
            logger.error("Database error: " + e.getMessage());
            throw new RuntimeException(e.getMessage()); // Exposes DB details
        }
        
        // Use:
        try {
            // Database operation
        } catch (SQLException e) {
            logger.error("Database operation failed for user {}: {}", userId, e.getMessage(), e);
            throw new ServiceException("Database operation failed"); // Generic message
        }

  - id: java-database-mass-assignment
    message: 'Mass assignment: JPA entity allows unrestricted field updates'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @Entity
          public class $CLASS {
            ...
          }
      - pattern: |
          public $TYPE update$ENTITY($ENTITY $PARAM) {
            return $REPOSITORY.save($PARAM);
          }
      - pattern-not-inside: |
          @JsonIgnore
          private $FIELD_TYPE $SENSITIVE_FIELD;
    metadata:
      category: mass-assignment
      cwe: CWE-915
      framework: jpa
      solution: |
        Use DTOs and validate field updates:
        
        // Instead of:
        @PostMapping("/users/{id}")
        public User updateUser(@PathVariable Long id, @RequestBody User user) {
            user.setId(id);
            return userRepository.save(user); // Mass assignment vulnerability
        }
        
        // Use:
        @PostMapping("/users/{id}")
        public User updateUser(@PathVariable Long id, @RequestBody @Valid UserUpdateDto dto) {
            User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("User not found"));
            
            // Explicitly update only allowed fields
            existingUser.setName(dto.getName());
            existingUser.setEmail(dto.getEmail());
            // Don't update sensitive fields like role, balance, etc.
            
            return userRepository.save(existingUser);
        }
        
        public class UserUpdateDto {
            @NotBlank
            private String name;
            
            @Email
            private String email;
            
            // No sensitive fields like role, isAdmin, etc.
        }

  - id: java-database-connection-leak
    message: 'Resource leak: Database connection not properly closed'
    languages:
      - java
    severity: WARNING
    patterns:
      # This pattern correctly matches the initialization of a Connection object
      - pattern: Connection $CONN = DriverManager.getConnection(...);
      # These patterns ensure the connection is not already being closed properly
      - pattern-not-inside: |
          try (Connection $CONN = $INIT) {
            ...
          }
      - pattern-not-inside: |
          try {
            ...
          } finally {
            $CONN.close();
          }
    metadata:
      category: connection-leak
      cwe: CWE-404
      solution: |
        Use try-with-resources for database connections:
        
        // Instead of:
        Connection conn = DriverManager.getConnection(url, user, password);
        PreparedStatement stmt = conn.prepareStatement(sql);
        ResultSet rs = stmt.executeQuery();
        // Resources not properly closed
        
        // Use:
        try (Connection conn = DriverManager.getConnection(url, user, password);
            PreparedStatement stmt = conn.prepareStatement(sql);
            ResultSet rs = stmt.executeQuery()) {
            
            // Process results
            while (rs.next()) {
                // Handle data
            }
        } // Resources automatically closed

  # ===========================================================================
  # 46. CLOUD SECURITY PATTERNS
  # ===========================================================================

  - id: java-aws-hardcoded-credentials
    message: 'Cloud security: Hardcoded AWS credentials'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              BasicAWSCredentials $CREDS = new BasicAWSCredentials("AKIA...", "...");
          - pattern: |
              AWSStaticCredentialsProvider.create(new BasicAWSCredentials("...", "..."));
    metadata:
      category: aws-credentials
      cwe: CWE-798
      platform: aws
      solution: |
        Use IAM roles or environment-based credentials:
        
        // Instead of:
        BasicAWSCredentials credentials = new BasicAWSCredentials("AKIAIOSFODNN7EXAMPLE", "wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY");
        
        // Use:
        // Option 1: Use IAM roles (recommended for EC2/Lambda)
        AmazonS3 s3 = AmazonS3ClientBuilder.standard()
            .withRegion(Regions.US_WEST_2)
            .build(); // Automatically uses IAM role
        
        // Option 2: Use environment variables
        AmazonS3 s3 = AmazonS3ClientBuilder.standard()
            .withCredentials(new EnvironmentVariableCredentialsProvider())
            .withRegion(Regions.US_WEST_2)
            .build();
        
        // Option 3: Use AWS credentials file
        AmazonS3 s3 = AmazonS3ClientBuilder.standard()
            .withCredentials(new ProfileCredentialsProvider())
            .withRegion(Regions.US_WEST_2)
            .build();

  - id: java-aws-s3-public-read
    message: 'S3 security: Bucket configured for public read access'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              $S3.setBucketAcl($BUCKET_NAME, CannedAccessControlList.PublicRead);
          - pattern: |
              $S3.setBucketPolicy($BUCKET_NAME, $POLICY);
      - metavariable-regex:
          metavariable: $POLICY
          regex: '.*"Principal":\s*"\*".*'
    metadata:
      category: s3-security
      cwe: CWE-732
      platform: aws
      solution: |
        Use restrictive S3 bucket policies:
        
        // Instead of:
        s3.setBucketAcl(bucketName, CannedAccessControlList.PublicRead);
        
        // Use:
        s3.setBucketAcl(bucketName, CannedAccessControlList.Private);
        
        // Create restrictive bucket policy
        String policyText = """
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {"AWS": "arn:aws:iam::ACCOUNT-ID:user/specific-user"},
              "Action": "s3:GetObject",
              "Resource": "arn:aws:s3:::bucket-name/*"
            }
          ]
        }
        """;
        
        s3.setBucketPolicy(bucketName, policyText);

  - id: java-gcp-service-account-key
    message: 'GCP security: Service account key in source code'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              ServiceAccountCredentials.fromStream(new ByteArrayInputStream("...".getBytes()));
          - pattern: |
              GoogleCredentials.fromStream(new FileInputStream("service-account-key.json"));
    metadata:
      category: gcp-credentials
      cwe: CWE-798
      platform: gcp
      solution: |
        Use environment-based authentication for GCP:
        
        // Instead of:
        GoogleCredentials credentials = ServiceAccountCredentials
            .fromStream(new FileInputStream("service-account-key.json"));
        
        // Use:
        // Option 1: Use environment variable GOOGLE_APPLICATION_CREDENTIALS
        GoogleCredentials credentials = GoogleCredentials.getApplicationDefault();
        
        // Option 2: Use Compute Engine metadata service (for GCE/GKE)
        GoogleCredentials credentials = ComputeEngineCredentials.create();
        
        // Option 3: Use workload identity (for GKE)
        // Configure workload identity and use application default credentials

  - id: java-azure-connection-string
    message: 'Azure security: Storage connection string in source code'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              CloudStorageAccount.parse("DefaultEndpointsProtocol=https;AccountName=...");
          - pattern: |
              BlobServiceClient $CLIENT = new BlobServiceClientBuilder()
                .connectionString("DefaultEndpointsProtocol=https;...")
                .buildClient();
    metadata:
      category: azure-credentials
      cwe: CWE-798
      platform: azure
      solution: |
        Use managed identity or environment variables for Azure:
        
        // Instead of:
        BlobServiceClient client = new BlobServiceClientBuilder()
            .connectionString("DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=mykey")
            .buildClient();
        
        // Use:
        // Option 1: Use managed identity
        BlobServiceClient client = new BlobServiceClientBuilder()
            .endpoint("https://myaccount.blob.core.windows.net")
            .credential(new ManagedIdentityCredentialBuilder().build())
            .buildClient();
        
        // Option 2: Use environment variables
        String connectionString = System.getenv("AZURE_STORAGE_CONNECTION_STRING");
        BlobServiceClient client = new BlobServiceClientBuilder()
            .connectionString(connectionString)
            .buildClient();

  # ===========================================================================
  # 47. MOBILE APPLICATION SECURITY EXTENDED
  # ===========================================================================

  - id: java-android-backup-sensitive-data
    message: 'Android security: Sensitive data stored that may be included in automatic backup'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: $PREFS.edit().putString("password", $PASSWORD).commit()
          - pattern: $PREFS.edit().putString("secret", $SECRET).commit()  
          - pattern: $PREFS.edit().putString("token", $TOKEN).commit()
          - pattern: $PREFS.edit().putString($KEY, $VALUE).commit()
          - pattern: $DATABASE.execSQL("CREATE TABLE sensitive_data ...")
          - pattern: $DATABASE.execSQL($SQL)
      - metavariable-regex:
          metavariable: $KEY  
          regex: '.*(password|secret|token|credential|key|auth).*'
    metadata:
      category: android-backup
      cwe: CWE-200
      platform: android
      solution: |
        Disable backup for sensitive data or use backup exclusion rules:
        
        // 1. Disable backup in AndroidManifest.xml:
        <application android:allowBackup="false" ...>
        
        // 2. Or exclude sensitive SharedPreferences:
        // Store sensitive data in a file excluded from backup
        SharedPreferences sensitivePrefs = getSharedPreferences("sensitive_prefs", 
            Context.MODE_PRIVATE | Context.MODE_NO_BACKUP);
        
        // 3. Or use backup exclusion rules in res/xml/data_extraction_rules.xml

  - id: java-android-root-detection-missing
    message: 'Android security: Missing root detection in security-sensitive app'
    languages:
      - java
    severity: INFO
    patterns:
      - pattern-inside: |
          public class $CLASS extends Activity {
            ...
          }
      - pattern: |
          @Override
          protected void onCreate(Bundle $BUNDLE) {
            ...
            // Payment or banking functionality without root check
            processPayment(...);
          }
    metadata:
      category: android-root-detection
      cwe: CWE-250
      platform: android
      solution: |
        Implement root detection for security-sensitive applications:
        
        public class RootDetection {
            public static boolean isDeviceRooted() {
                return checkRootMethod1() || checkRootMethod2() || checkRootMethod3();
            }
            
            private static boolean checkRootMethod1() {
                String buildTags = android.os.Build.TAGS;
                return buildTags != null && buildTags.contains("test-keys");
            }
            
            private static boolean checkRootMethod2() {
                String[] paths = {
                    "/system/app/Superuser.apk",
                    "/sbin/su",
                    "/system/bin/su",
                    "/system/xbin/su",
                    "/data/local/xbin/su",
                    "/data/local/bin/su",
                    "/system/sd/xbin/su",
                    "/system/bin/failsafe/su",
                    "/data/local/su"
                };
                
                for (String path : paths) {
                    if (new File(path).exists()) return true;
                }
                return false;
            }
            
            private static boolean checkRootMethod3() {
                Process process = null;
                try {
                    process = Runtime.getRuntime().exec(new String[] { "/system/xbin/which", "su" });
                    BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    return in.readLine() != null;
                } catch (Exception e) {
                    return false;
                } finally {
                    if (process != null) process.destroy();
                }
            }
        }

  - id: java-android-ssl-pinning-missing
    message: 'Android security: Missing SSL certificate pinning for API calls'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              OkHttpClient $CLIENT = new OkHttpClient();
              Request $REQUEST = new Request.Builder().url("https://api.example.com/...").build();
          - pattern: |
              HttpURLConnection $CONN = (HttpURLConnection) new URL("https://api.example.com/...").openConnection();
    metadata:
      category: android-ssl-pinning
      cwe: CWE-295
      platform: android
      solution: |
        Implement SSL certificate pinning:
        
        // Instead of:
        OkHttpClient client = new OkHttpClient();
        
        // Use:
        CertificatePinner certificatePinner = new CertificatePinner.Builder()
            .add("api.example.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
            .add("api.example.com", "sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=") // Backup pin
            .build();
        
        OkHttpClient client = new OkHttpClient.Builder()
            .certificatePinner(certificatePinner)
            .build();

  - id: java-android-debuggable-release
    message: 'Android security: Debuggable flag enabled in release build'
    languages:
      - xml
    severity: ERROR
    patterns:
      - pattern: <application android:debuggable="true" ...>
    paths:
      include:
        - "**/AndroidManifest.xml"
    metadata:
      category: android-debug
      cwe: CWE-489
      platform: android
      solution: |
        Disable debugging in production builds:
        
        // Instead of:
        <application android:debuggable="true" android:name=".MyApp">
        
        // Use:
        <application android:debuggable="false" android:name=".MyApp">
        
        // Better approach - Use build variants in build.gradle:
        buildTypes {
            debug {
                debuggable true
            }
            release {
                debuggable false
                minifyEnabled true
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            }
        }

  # ===========================================================================
  # 48. ADDITIONAL INJECTION VULNERABILITIES
  # ===========================================================================

  - id: java-xpath-injection
    message: 'XPath injection: User input in XPath expression'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              $XPATH.evaluate("//user[@name='" + $USER_INPUT + "']", $DOC);
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              ...
              XPathExpression $EXPR = $XPATH.compile("//user[@id=" + $USER_INPUT + "]");
    metadata:
      category: xpath-injection
      cwe: CWE-91
      solution: |
        Use parameterized XPath expressions or input validation:
        
        // Instead of:
        String userName = request.getParameter("username");
        String xpathExpr = "//user[@name='" + userName + "']";
        NodeList nodes = (NodeList) xpath.evaluate(xpathExpr, doc, XPathConstants.NODESET);
        
        // Use:
        String userName = request.getParameter("username");
        
        // Validate and escape input
        if (userName.contains("'") || userName.contains("\"") || userName.contains("or") || userName.contains("and")) {
            throw new IllegalArgumentException("Invalid username format");
        }
        
        // Use XPath variables (if supported by implementation)
        XPathExpression expr = xpath.compile("//user[@name=$username]");
        // Set variable context
        SimpleVariableResolver resolver = new SimpleVariableResolver();
        resolver.addVariable("username", userName);
        xpath.setXPathVariableResolver(resolver);
        
        NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);

  - id: java-json-injection
    message: 'JSON injection: User input directly concatenated into JSON'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              String $JSON = "{\"name\":\"" + $USER_INPUT + "\"}";
          - pattern: |
              StringBuilder $JSON = new StringBuilder();
              $JSON.append("{\"value\":\"").append($USER_INPUT).append("\"}");
    metadata:
      category: json-injection
      cwe: CWE-74
      solution: |
        Use proper JSON libraries for serialization:
        
        // Instead of:
        String userName = request.getParameter("username");
        String json = "{\"name\":\"" + userName + "\"}";
        
        // Use:
        String userName = request.getParameter("username");
        
        // Use Jackson ObjectMapper
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> data = Map.of("name", userName);
        String json = mapper.writeValueAsString(data);
        
        // Or use JsonNode for dynamic construction
        ObjectNode node = mapper.createObjectNode();
        node.put("name", userName); // Automatically escaped
        String json = mapper.writeValueAsString(node);

  - id: java-csv-injection
    message: 'CSV injection: User input may contain formula injection'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              $CSV_WRITER.write($USER_INPUT + ",");
          - pattern: |
              PrintWriter $WRITER = response.getWriter();
              $WRITER.println($USER_INPUT + "," + $OTHER_DATA);
    metadata:
      category: csv-injection
      cwe: CWE-1236
      solution: |
        Sanitize CSV data to prevent formula injection:
        
        // Instead of:
        String userInput = request.getParameter("data");
        csvWriter.write(userInput + ",");
        
        // Use:
        String userInput = request.getParameter("data");
        String sanitizedInput = sanitizeCSVField(userInput);
        csvWriter.write(sanitizedInput + ",");
        
        private String sanitizeCSVField(String field) {
            if (field == null) return "";
            
            // Remove or escape dangerous characters that could be interpreted as formulas
            if (field.startsWith("=") || field.startsWith("+") || 
                field.startsWith("-") || field.startsWith("@")) {
                field = "'" + field; // Prefix with single quote to treat as text
            }
            
            // Escape quotes and wrap in quotes if contains comma or newline
            if (field.contains(",") || field.contains("\"") || field.contains("\n")) {
                field = "\"" + field.replace("\"", "\"\"") + "\"";
            }
            
            return field;
        }

  - id: java-xml-injection
    message: 'XML injection: User input directly inserted into XML'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              String $USER_INPUT = request.getParameter(...);
              String $XML = "<user><name>" + $USER_INPUT + "</name></user>";
          - pattern: |
              $ELEMENT.setTextContent($USER_INPUT);
      - pattern-not-inside: |
          String $ESCAPED = StringEscapeUtils.escapeXml($USER_INPUT);
          ...
    metadata:
      category: xml-injection
      cwe: CWE-91
      solution: |
        Use proper XML APIs or escape XML content:
        
        // Instead of:
        String userName = request.getParameter("username");
        String xml = "<user><name>" + userName + "</name></user>";
        
        // Use:
        String userName = request.getParameter("username");
        
        // Use DOM API
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.newDocument();
        
        Element root = doc.createElement("user");
        Element name = doc.createElement("name");
        name.setTextContent(userName); // Automatically escaped
        root.appendChild(name);
        doc.appendChild(root);
        
        // Or escape manually
        String escapedName = StringEscapeUtils.escapeXml11(userName);
        String xml = "<user><name>" + escapedName + "</name></user>";

  # ===========================================================================
  # 49. ADDITIONAL FRAMEWORK SECURITY PATTERNS
  # ===========================================================================

  - id: java-thymeleaf-template-injection
    message: 'Template injection: Thymeleaf template with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $TEMPLATE = request.getParameter(...);
              $ENGINE.process($TEMPLATE, $CONTEXT);
          - pattern: |
              @RequestMapping(...)
              public String $METHOD(Model $MODEL, @RequestParam String $TEMPLATE) {
                return $TEMPLATE;
              }
    metadata:
      category: thymeleaf-injection
      cwe: CWE-94
      framework: thymeleaf
      solution: |
        Use predefined templates and validate template names:
        
        // Instead of:
        @RequestMapping("/render")
        public String renderTemplate(@RequestParam String template) {
            return template; // User controls template name
        }
        
        // Use:
        @RequestMapping("/render")
        public String renderTemplate(@RequestParam String templateType) {
            Map<String, String> allowedTemplates = Map.of(
                "user", "user-profile",
                "admin", "admin-dashboard",
                "report", "monthly-report"
            );
            
            String template = allowedTemplates.get(templateType);
            if (template == null) {
                return "error/invalid-template";
            }
            
            return template;
        }

  - id: java-mustache-template-injection
    message: 'Template injection: Mustache template with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $TEMPLATE = request.getParameter(...);
              Mustache $MUSTACHE = $FACTORY.compile($TEMPLATE);
          - pattern: |
              String $TEMPLATE = request.getParameter(...);
              $MUSTACHE.execute($WRITER, $TEMPLATE);
    metadata:
      category: mustache-injection
      cwe: CWE-94
      framework: mustache
      solution: |
        Use predefined Mustache templates:
        
        // Instead of:
        String userTemplate = request.getParameter("template");
        Mustache mustache = mustacheFactory.compile(userTemplate);
        
        // Use:
        String templateName = request.getParameter("templateName");
        Set<String> allowedTemplates = Set.of("welcome", "notification", "report");
        
        if (!allowedTemplates.contains(templateName)) {
            throw new IllegalArgumentException("Invalid template name");
        }
        
        Mustache mustache = mustacheFactory.compile(templateName + ".mustache");

  - id: java-groovy-script-injection
    message: 'Script injection: Groovy script execution with user input'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $SCRIPT = request.getParameter(...);
              GroovyShell $SHELL = new GroovyShell();
              $SHELL.evaluate($SCRIPT);
          - pattern: |
              String $SCRIPT = request.getParameter(...);
              $ENGINE.eval($SCRIPT);
    metadata:
      category: groovy-injection
      cwe: CWE-94
      framework: groovy
      solution: |
        Avoid dynamic script execution or use sandboxed environments:
        
        // Instead of:
        String userScript = request.getParameter("script");
        GroovyShell shell = new GroovyShell();
        Object result = shell.evaluate(userScript);
        
        // Use:
        String operation = request.getParameter("operation");
        Map<String, Closure> allowedOperations = Map.of(
            "calculate", { params -> params.a + params.b },
            "format", { params -> String.format("Hello %s", params.name) }
        );
        
        Closure operation = allowedOperations.get(operationName);
        if (operation != null) {
            Object result = operation.call(parameters);
        }

  # ===========================================================================
  # 50. ADDITIONAL VALIDATION AND SANITIZATION
  # ===========================================================================

  - id: java-unicode-normalization-bypass
    message: 'Input validation bypass: Unicode normalization can bypass filters'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              if ($INPUT.contains("script")) {
                throw new SecurityException(...);
              }
          - pattern: |
              if ($INPUT.matches(".*[<>\"'].*")) {
                throw new SecurityException(...);
              }
      - pattern-not-inside: |
          String $NORMALIZED = Normalizer.normalize($INPUT, Normalizer.Form.NFC);
          ...
    metadata:
      category: unicode-bypass
      cwe: CWE-176
      solution: |
        Normalize Unicode input before validation:
        
        // Instead of:
        String userInput = request.getParameter("data");
        if (userInput.contains("script")) {
            throw new SecurityException("Invalid input");
        }
        
        // Use:
        String userInput = request.getParameter("data");
        String normalized = Normalizer.normalize(userInput, Normalizer.Form.NFC);
        
        if (normalized.toLowerCase().contains("script")) {
            throw new SecurityException("Invalid input");
        }
        
        // Also check for homograph attacks
        if (containsSuspiciousUnicode(normalized)) {
            throw new SecurityException("Suspicious unicode characters");
        }
        
        private boolean containsSuspiciousUnicode(String input) {
            // Check for mixed scripts, invisible characters, etc.
            for (int i = 0; i < input.length(); i++) {
                int codepoint = input.codePointAt(i);
                if (Character.getType(codepoint) == Character.FORMAT ||
                    Character.getType(codepoint) == Character.CONTROL ||
                    Character.getType(codepoint) == Character.PRIVATE_USE) {
                    return true;
                }
            }
            return false;
        }

  - id: java-parameter-pollution-http
    message: 'HTTP Parameter Pollution: Multiple parameters with same name'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern: |
          String[] $VALUES = request.getParameterValues($PARAM_NAME);
          String $VALUE = $VALUES[$INDEX];
      - pattern-not-inside: |
          if ($VALUES.length > 1) {
            throw ...;
          }
    metadata:
      category: parameter-pollution
      cwe: CWE-235
      solution: |
        Handle parameter pollution by validating parameter count:
        
        // Instead of:
        String[] values = request.getParameterValues("amount");
        String amount = values[0]; // Might not be what user intended
        
        // Use:
        String[] values = request.getParameterValues("amount");
        if (values == null || values.length == 0) {
            throw new IllegalArgumentException("Amount parameter required");
        }
        
        if (values.length > 1) {
            logger.warn("Multiple amount parameters detected: {}", Arrays.toString(values));
            throw new IllegalArgumentException("Multiple amount parameters not allowed");
        }
        
        String amount = values[0];

  - id: java-content-type-validation-missing
    message: 'Input validation: Missing Content-Type validation for file uploads'
    languages:
      - java
    severity: WARNING
    patterns:
      - pattern-inside: |
          @PostMapping(...)
          public $TYPE $METHOD(@RequestParam("file") MultipartFile $FILE) {
            ...
          }
      - pattern: $FILE.transferTo($DEST)
      - pattern-not-inside: |
          String $CONTENT_TYPE = $FILE.getContentType();
          ...
          if (!$ALLOWED_TYPES.contains($CONTENT_TYPE)) {
            ...
          }
    metadata:
      category: file-upload-validation
      cwe: CWE-434
      solution: |
        Validate file content type and magic bytes:
        
        // Instead of:
        @PostMapping("/upload")
        public String uploadFile(@RequestParam("file") MultipartFile file) {
            file.transferTo(new File("/uploads/" + file.getOriginalFilename()));
            return "success";
        }
        
        // Use:
        @PostMapping("/upload")
        public String uploadFile(@RequestParam("file") MultipartFile file) {
            // Validate content type
            String contentType = file.getContentType();
            Set<String> allowedTypes = Set.of("image/jpeg", "image/png", "application/pdf");
            
            if (!allowedTypes.contains(contentType)) {
                throw new IllegalArgumentException("Invalid file type: " + contentType);
            }
            
            // Validate magic bytes to prevent content-type spoofing
            if (!isValidFileType(file, contentType)) {
                throw new IllegalArgumentException("File content doesn't match declared type");
            }
            
            // Generate safe filename
            String safeFileName = UUID.randomUUID() + "_" + 
                Paths.get(file.getOriginalFilename()).getFileName().toString();
            
            file.transferTo(new File("/secure/uploads/" + safeFileName));
            return "success";
        }
        
        private boolean isValidFileType(MultipartFile file, String expectedType) {
            try {
                byte[] header = new byte[8];
                file.getInputStream().read(header);
                
                // Check magic bytes based on expected type
                switch (expectedType) {
                    case "image/jpeg":
                        return header[0] == (byte) 0xFF && header[1] == (byte) 0xD8;
                    case "image/png":
                        return header[0] == (byte) 0x89 && header[1] == (byte) 0x50 &&
                               header[2] == (byte) 0x4E && header[3] == (byte) 0x47;
                    case "application/pdf":
                        return header[0] == (byte) 0x25 && header[1] == (byte) 0x50 &&
                               header[2] == (byte) 0x44 && header[3] == (byte) 0x46;
                    default:
                        return true; // Unknown type, allow
                }
            } catch (IOException e) {
                return false;
            }
        }

  - id: java-runtime-exec-command-injection
    message: 'Command injection vulnerability: User input concatenated into Runtime.exec() command'
    languages:
      - java
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              String $COMMAND = $CMD + $INPUT;
              ...
              Runtime.getRuntime().exec($COMMAND);
          - pattern: |
              String $COMMAND = $CMD + $INPUT + $SUFFIX;
              ...
              Runtime.getRuntime().exec($COMMAND);
          - pattern: |
              Runtime.getRuntime().exec($CMD + $INPUT);
          - pattern: |
              Runtime.getRuntime().exec($CMD + $INPUT + $SUFFIX);
          - pattern: |
              String $COMMAND = String.format($FORMAT, ..., $INPUT, ...);
              ...
              Runtime.getRuntime().exec($COMMAND);
          - pattern: |
              Runtime.getRuntime().exec(String.format($FORMAT, ..., $INPUT, ...));
          - pattern: |
              StringBuilder $SB = new StringBuilder();
              ...
              $SB.append($INPUT);
              ...
              Runtime.getRuntime().exec($SB.toString());
          - pattern: |
              String $COMMAND = $BUILDER.append($INPUT).toString();
              ...
              Runtime.getRuntime().exec($COMMAND);
    metadata:
      category: security
      cwe: 
        - "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
      owasp:
        - "A03:2021 - Injection"
      confidence: high
      impact: high
      likelihood: medium
      subcategory:
        - vuln
      technology:
        - java
      references:
        - "https://owasp.org/www-community/attacks/Command_Injection"
        - "https://cwe.mitre.org/data/definitions/78.html"
      solution: |
        Use ProcessBuilder with validated input instead of Runtime.exec() with string concatenation to prevent command injection:

        // Instead of:
        String fileName = getUserInput();
        String command = "cat " + fileName;  // Vulnerable to injection
        Runtime.getRuntime().exec(command);

        // Use:
        String fileName = validateFileName(getUserInput());
        ProcessBuilder pb = new ProcessBuilder("cat", fileName);
        Process process = pb.start();

        // For file operations, validate input first:
        private String validateFileName(String input) {
            // Remove dangerous characters and validate path
            String sanitized = input.replaceAll("[;&|`$(){}\\[\\]<>]", "");
            Path safePath = Paths.get(sanitized).normalize();
            if (!safePath.startsWith("/safe/directory")) {
                throw new IllegalArgumentException("Invalid file path");
            }
            return safePath.toString();
        }

        // Better: Use Java APIs instead of external commands
        try {
            String content = Files.readString(Paths.get(validatedFileName));
            System.out.println(content);
        } catch (IOException e) {
            // Handle error
        }